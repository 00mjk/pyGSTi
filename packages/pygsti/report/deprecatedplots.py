#def direct2x_comp_boxplot( xvals, yvals, xy_gatestring_dict, dataset, directGatesets, strs, xlabel="", ylabel="",
#                             m=None, M=None, scale=1.0, prec='compact', title="Direct 2x Chi^2 Comparison", sumUp=False,
#                             boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
#                             save_to=None, ticSize=20, invert=False, gateLabelAliases=None):
#    """
#    Create a box plot indicating how well the Direct-X estimates of string s
#    predict the data for 2s (the string repeated)
#
#    Creates a color box plot whose boxes (or box, if sumUp == True) at
#    position (x,y) display the chi^2 for the (x,y) base gate string
#    **repeated twice** (if this data is available), where the probabilities
#    used in the chi^2 calculation are obtained using the Direct-X gateset
#    for the un-repeated (x,y) base gate string.  That is, the box(es) at
#    coordinates x,y show how well the Direct-X estimates of xy_gatestring_dict[(x,y)]
#    reproduce the observed frequencies of 2 * xy_gatestring_dict[(x,y)] (the
#    gate string repeated twice).
#
#    Parameters
#    ----------
#    xvals, yvals : list
#        List of x and y values. Elements can be any hashable quantity, and will be converted
#        into x and y tic labels.  Tuples of strings are converted specially for nice latex
#        rendering of gate strings.
#
#    xy_gatestring_dict : dict
#        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
#        a gate string can either be a GateString object or a tuple of gate labels.  Provides
#        the mapping between x,y pairs and gate strings.  None values are allowed, and
#        indicate that there is not data for that x,y pair and nothing should be plotted.
#
#    dataset : DataSet
#        The data used to specify frequencies and counts
#
#    directGatesets : dict
#        Dictionary with keys == gate strings and values == GateSets.
#        directGatesets[sigma] must be a GateSet which contains an estimate
#        of sigma stored under the gate label "GsigmaLbl".
#
#    strs : 2-tuple
#        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)
#
#    xlabel, ylabel : str, optional
#        X and Y axis labels
#
#    m, M : float, optional
#        Min and max values of the color scale.
#
#    scale : float, optional
#        Scaling factor to adjust the size of the final figure.
#
#    prec : int, optional
#        Precision for box labels.  Allowed values are:
#          'compact' = round to nearest whole number using at most 3 characters
#          'compacthp' = show as much precision as possible using at most 3 characters
#          int >= 0 = fixed precision given by int
#          int <  0 = number of significant figures given by -int
#
#    title : string, optional
#        Plot title (latex can be used)
#
#    sumUp : bool, optional
#        False displays each matrix element as it's own color box
#        True sums the elements of each (x,y) matrix and displays
#        a single color box for the sum.
#
#    boxLabels : bool, optional
#        Whether box labels are displayed.  It takes much longer to
#        generate the figure when this is set to True.
#
#    histogram : bool, optional
#        Whether a histogram of the matrix element values or summed matrix
#        values (depending on sumUp) should also be computed and displayed.
#
#    histBins : int, optional
#        The number of bins to use in the histogram.
#
#    minProbClipForWeighting : float, optional
#        defines the clipping interval for the statistical weight used
#        within the chi^2 function (see chi2fn).
#
#    save_to : str, optional
#        save figure to this filename (usually ending in .pdf)
#
#    ticSize : int, optional
#        size of tic marks
#
#    invert : bool, optional
#        If True, invert the nesting order of the nested color box plot (applicable
#        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
#        the x and y axes.
#
#    gateLabelAliases : dictionary, optional
#        Dictionary whose keys are gate label "aliases" and whose values are tuples
#        corresponding to what that gate label should be expanded into before querying
#        the dataset. Defaults to the empty dictionary (no aliases defined)
#        e.g. gateLabelAliases['Gx^3'] = ('Gx','Gx','Gx')
#
#
#    Returns
#    -------
#    rptFig : ReportFigure
#        The encapsulated matplotlib figure that was generated.   Extra figure
#        info is a dict with keys:
#
#        nUsedXs : int
#            The number of used X-values, proportional to the overall final figure width
#        nUsedYs : int
#            The number of used Y-values, proportional to the overall final figure height
#    """
#    prepStrs, effectStrs = strs
#    nanMx = _np.nan * _np.zeros( (len(strs[1]),len(strs[0])), 'd')
#    gatestring_filter = None #don't use gatestring filters for now
#
#    def mx_fn(gateStr,x,y):
#
#        if gateStr is None: return nanMx
#        directGateset = directGatesets[ gateStr ] #contains "GsigmaLbl" gate <=> gateStr
#        spamlabels = directGateset.get_spam_labels()
#
#        try:
#            gsmap = get_gatestring_map(gateStr*2, dataset, strs, None,
#                                       gatestring_filter, gateLabelAliases)
#            gsmap_pr = get_gatestring_map(_objs.GateString(
#                    ("GsigmaLbl","GsigmaLbl") ), None,
#                    strs, None, gatestring_filter) 
#                   # Note: don't test for dataset membership here (dataset
#                   #       doesn't contain "GsigmaLbl"!)
#            cntMxs = total_count_matrix(gsmap, dataset)[None,:,:]
#            probMxs = probability_matrices( gsmap_pr, directGateset, spamlabels ) # no probs_precomp_dict
#            freqMxs = frequency_matrices( gsmap, dataset, spamlabels)
#            chiSqMxs= _tools.chi2fn( cntMxs, probMxs, freqMxs,
#                                     minProbClipForWeighting)
#        except:
#            return nanMx #if something fails, just punt
#
#        return chiSqMxs.sum(axis=0) # sum over spam labels
#
#    xvals,yvals,subMxs,n_boxes,dof = _computeSubMxs(xvals,yvals,xy_gatestring_dict,mx_fn,sumUp)
#    max_abs = max([ _np.max(_np.abs(_np.nan_to_num(subMxs[iy][ix])))
#                    for ix in range(len(xvals))
#                    for iy in range(len(yvals)) ])
#    if max_abs == 0: max_abs = 1e-6 # pick a nonzero value if all entries are zero or nan
#    m = -max_abs if m is None else m
#    M = +max_abs if M is None else M
#    stdcmap = StdColormapFactory('div', n_boxes=n_boxes, vmin=m, vmax=M, dof=dof)
#
#    return generate_boxplot( xvals, yvals, xy_gatestring_dict, subMxs, stdcmap, xlabel, ylabel,
#                            scale,prec,title,sumUp,boxLabels,histogram,histBins,
#                            save_to,ticSize,invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$" )
#
#
#def direct_deviation_boxplot( xvals, yvals, xy_gatestring_dict, dataset, gateset, directGatesets,
#                                 xlabel="", ylabel="", m=None, M=None, scale=1.0, prec='compact', title="Direct Deviation",
#                                 boxLabels=True, histogram=False, histBins=50, save_to=None, ticSize=20):
#    """
#    Create a box plot showing the difference in max-fidelity-with-unitary
#    between gateset's estimate for each base gate string and the Direct-X estimate.
#
#    Creates a color box plot whose box at position (x,y) shows the
#    the difference between:
#
#    1. the upper bound of the fidelity between the map corresponding to
#       this base gate string using the Direct-X estimate of this map
#       (i.e. by using only data relevant to this particular string) and
#       a unitary map.
#
#    2. the upper bound of the fidelity between the map corresponding to
#       this base gate string using gateset (i.e. by multiplying together
#       single gate estimates) and a unitary map.
#
#    The plotted quantity indicates how much more "unitary", i.e. how
#    much less "depolarized", the map corresponding to each base gate
#    sequence is when considering only the data immediately relevant
#    to predicting that map. Large absolute values indicate that
#    the data used for fitting other gate sequences has made the estimate
#    for the subject gate sequence more depolarized (~worse) than the
#    data for the sequence alone would suggest.
#
#    Parameters
#    ----------
#    xvals, yvals : list
#        List of x and y values. Elements can be any hashable quantity, and will be converted
#        into x and y tic labels.  Tuples of strings are converted specially for nice latex
#        rendering of gate strings.
#
#    xy_gatestring_dict : dict
#        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
#        a gate string can either be a GateString object or a tuple of gate labels.  Provides
#        the mapping between x,y pairs and gate strings.  None values are allowed, and
#        indicate that there is not data for that x,y pair and nothing should be plotted.
#
#    dataset : DataSet
#        The data used to specify frequencies and counts
#
#    directGatesets : dict
#        Dictionary with keys == gate strings and values == GateSets.
#        directGatesets[sigma] must be a GateSet which contains an estimate
#        of sigma stored under the gate label "GsigmaLbl".
#
#    xlabel, ylabel : str, optional
#        X and Y axis labels
#
#    m, M : float, optional
#        Min and max values of the color scale.
#
#    scale : float, optional
#        Scaling factor to adjust the size of the final figure.
#
#    prec : int, optional
#        Precision for box labels.  Allowed values are:
#          'compact' = round to nearest whole number using at most 3 characters
#          'compacthp' = show as much precision as possible using at most 3 characters
#          int >= 0 = fixed precision given by int
#          int <  0 = number of significant figures given by -int
#
#    title : string, optional
#        Plot title (latex can be used)
#
#    boxLabels : bool, optional
#        Whether box labels are displayed.  It takes much longer to
#        generate the figure when this is set to True.
#
#    histogram : bool, optional
#        Whether a histogram of the matrix element values or summed matrix
#        values (depending on sumUp) should also be computed and displayed.
#
#    histBins : int, optional
#        The number of bins to use in the histogram.
#
#    save_to : str, optional
#        save figure to this filename (usually ending in .pdf)
#
#    ticSize : int, optional
#        size of tic marks
#
#    Returns
#    -------
#    rptFig : ReportFigure
#        The encapsulated matplotlib figure that was generated.  Extra figure
#        info is a dict with keys:
#
#        nUsedXs : int
#            The number of used X-values, proportional to the overall final figure width
#        nUsedYs : int
#            The number of used Y-values, proportional to the overall final figure height
#    """
#    def mx_fn(gateStr,x,y):
#        if gateStr is None: return _np.nan * _np.zeros( (1,1), 'd')
#        gate = gateset.product( gateStr )
#        gate_direct = directGatesets[ gateStr ].gates[ "GsigmaLbl" ]
#        #evals = _np.linalg.eigvals(gate)
#        #evals_direct = _np.linalg.eigvals(gate_direct)
#        ubF, _ = _tools.fidelity_upper_bound(gate)
#        ubF_direct, _ = _tools.fidelity_upper_bound(gate_direct)
#        return _np.array( ubF_direct - ubF, dtype='float64' )
#
#    xvals, yvals, subMxs, _, _ = _computeSubMxs(xvals,yvals,xy_gatestring_dict,mx_fn,True)
#    max_abs = max([ _np.max(_np.abs(_np.nan_to_num(subMxs[iy][ix])))
#                    for ix in range(len(xvals))
#                    for iy in range(len(yvals)) ])
#    if max_abs == 0: max_abs = 1e-6 # pick a nonzero value if all entries are zero or nan
#    m = -max_abs if m is None else m
#    M = +max_abs if M is None else M
#    stdcmap = StdColormapFactory('div', vmin=m, vmax=M, midpoint=0)
#    return generate_boxplot( xvals, yvals, xy_gatestring_dict, subMxs, stdcmap, xlabel, ylabel,
#                            scale,prec,title,True,boxLabels,histogram,histBins,save_to,ticSize)



#def whack_a_chi2_mole_boxplot( gatestringToWhack, allGatestringsUsedInChi2Opt,
#                               xvals, yvals, xy_gatestring_dict, dataset,
#                               gateset, strs, xlabel="", ylabel="", m=None,
#                               M=None, scale=1.0, prec='compact',
#                               title="Whack a Chi^2 Mole", sumUp=False,
#                               boxLabels=True, histogram=False, histBins=50,
#                               minProbClipForWeighting=1e-4, save_to=None, 
#                               ticSize=20, whackWith=10.0, invert=False, 
#                               fidpair_filters=None, gatestring_filters=None,
#                               gateLabelAliases=None):
#    """
#    Create a box plot indicating how the chi^2 would change if the chi^2 of one
#      base gate string blocks were forced to be smaller ("whacked").
#
#    Creates a color box plot which displays the change in chi^2 caused by
#      changing the gate set parameters such that the chi^2 of gatestringToWhack's
#      (x,y) block decreases by whackWith.  This changes the gate set along
#      the direction of parameter space given by the gradient of chi^2 restricted
#      to only those gatestrings in gatestringToWhack's block, and the the
#      displayed difference in chi^2 values are based on the linear interpolation
#      of the full gradient of chi^2 after this change.
#
#    Parameters
#    ----------
#    gatestringToWhack : GateString or tuple
#        The **base** gate sequence for which chi^2 will be decreased.
#
#    allGatestringsUsedInChi2Opt : list of GateStrings or tuples
#        List of all the gate strings used to form the total chi^2 that is being decreased.
#
#    xvals, yvals : list
#        List of x and y values. Elements can be any hashable quantity, and will be converted
#        into x and y tic labels.  Tuples of strings are converted specially for nice latex
#        rendering of gate strings.
#
#    xy_gatestring_dict : dict
#        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
#        a gate string can either be a GateString object or a tuple of gate labels.  Provides
#        the mapping between x,y pairs and gate strings.  None values are allowed, and
#        indicate that there is not data for that x,y pair and nothing should be plotted.
#
#    dataset : DataSet
#        The data used to specify frequencies and counts
#
#    gateset : GateSet
#        The gate set used for computing probabilities
#
#    strs : 2-tuple
#        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)
#
#    xlabel, ylabel : str, optional
#        X and Y axis labels
#
#    m, M : float, optional
#        Min and max values of the color scale.
#
#    scale : float, optional
#        Scaling factor to adjust the size of the final figure.
#
#    prec : int, optional
#        Precision for box labels.  Allowed values are:
#          'compact' = round to nearest whole number using at most 3 characters
#          'compacthp' = show as much precision as possible using at most 3 characters
#          int >= 0 = fixed precision given by int
#          int <  0 = number of significant figures given by -int
#
#    title : string, optional
#        Plot title (latex can be used)
#
#    sumUp : bool, optional
#        False displays each matrix element as it's own color box
#        True sums the elements of each (x,y) matrix and displays
#        a single color box for the sum.
#
#    boxLabels : bool, optional
#        Whether box labels are displayed.  It takes much longer to
#        generate the figure when this is set to True.
#
#    histogram : bool, optional
#        Whether a histogram of the matrix element values or summed matrix
#        values (depending on sumUp) should also be computed and displayed.
#
#    histBins : int, optional
#        The number of bins to use in the histogram.
#
#    minProbClipForWeighting : float, optional
#        defines the clipping interval for the statistical weight used
#        within the chi^2 function (see chi2fn).
#
#    save_to : str, optional
#        save figure to this filename (usually ending in .pdf)
#
#    ticSize : int, optional
#        size of tic marks
#
#    whackWith : float, optional
#        the total amount to decrease chi^2 by.  This number just sets the
#        overall scale of the numbers displayed, since the extrapolation is
#        linear.
#
#    invert : bool, optional
#        If True, invert the nesting order of the nested color box plot (applicable
#        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
#        the x and y axes.
#
#    fidpair_filters : dict, optional
#        If not None, a dictionary whose keys are (x,y) tuples and whose values
#        are lists of (iRhoStr,iEStr) tuples specifying a subset of all the
#        prepStr,effectStr pairs to include in the plot for each particular
#        (x,y) sub-block.
#
#    gatestring_filters : dict, optional
#        If not None, a dictionary whose keys are (x,y) tuples and whose
#        values are lists of GateString objects specifying which elements should
#        be computed and displayed in the (x,y) sub-block of the plot.
#
#    gateLabelAliases : dictionary, optional
#        Dictionary whose keys are gate label "aliases" and whose values are tuples
#        corresponding to what that gate label should be expanded into before querying
#        the dataset. Defaults to the empty dictionary (no aliases defined)
#        e.g. gateLabelAliases['Gx^3'] = ('Gx','Gx','Gx')
#
#
#    Returns
#    -------
#    rptFig : ReportFigure
#        The encapsulated matplotlib figure that was generated.  Extra figure
#        info is a dict with keys:
#
#        nUsedXs : int
#            The number of used X-values, proportional to the overall final figure width
#        nUsedYs : int
#            The number of used Y-values, proportional to the overall final figure height
#    """
#
#    #We want the derivative of chi^2 = sum_i N_i*(p_i-f_i)^2 / p_i  (i over gatestrings & spam labels)
#    # and the ability to separate the chi^2 of just "gatestringToWhack" (sandwiched with strs, optionally)
#    # This latter derivative (w.r.t gateset params) gives the direction in gateset space to move to reduce
#    #   the "whacked" string(s) chi2.  Applying this direction to the full chi^2 (or to other base strings
#    #   sandwiched with strs) will give the relative change in the chi^2 for these strings if the whacked
#    #   string(s) was in fact whacked.
#    # D(chi^2) = sum_i N_i * [ 2(p_i-f_i)*dp_i / p_i - (p_i-f_i)^2 / p_i^2 * dp_i ]
#    #          = sum_i N_i * (p_i-f_i) / p_i * [2 - (p_i-f_i)/p_i   ] * dp_i
#    prepStrs, effectStrs = strs
#    spamLabels = gateset.get_spam_labels() #this list fixes the ordering of the spam labels
#    spam_lbl_rows = { sl:i for (i,sl) in enumerate(spamLabels) }
#    vec_gs_len = gateset.num_params()
#
#    N      = _np.empty( len(allGatestringsUsedInChi2Opt) )
#    f      = _np.empty( (len(spamLabels),len(allGatestringsUsedInChi2Opt)) )
#    probs  = _np.empty( (len(spamLabels),len(allGatestringsUsedInChi2Opt)) )
#    dprobs = _np.empty( (len(spamLabels),len(allGatestringsUsedInChi2Opt),vec_gs_len) )
#
#    ds_gatestrings = _tools.find_replace_tuple_list(allGatestringsUsedInChi2Opt,gateLabelAliases)
#    for (i,gateStr) in enumerate(ds_gatestrings):
#        N[i] = float(dataset[gateStr].total())
#        for k,sl in enumerate(spamLabels):
#            f[k,i] = dataset[gateStr].fraction(sl)
#
#    evTree = gateset.bulk_evaltree(allGatestringsUsedInChi2Opt)
#    gateset.bulk_fill_dprobs(dprobs, spam_lbl_rows, evTree, prMxToFill=probs)
#
#    t = ((probs - f)/probs)[:,:,None]
#    Dchi2 = N[None,:,None] * t * (2 - t) * dprobs  # (1,M,1) * (K,M,1) * (K,M,N)
#
#    # LEXICOGRAPHICAL VS MATRIX ORDER
#    
#    #Since we don't know which (x,y) pair the gatestringToWhack is associated with,
#    # we try to wack *all* possible fiducial pairs.
#    gatestringsToWhack = [ (prepStr + gatestringToWhack + effectStr)
#                           for prepStr in prepStrs for effectStr in effectStrs ]
#
#    whacked_indices = []
#    for s in gatestringsToWhack:
#        try: whacked_indices.append( allGatestringsUsedInChi2Opt.index(s) )
#        except ValueError: pass #just ignore gatestrings that aren't available
#    whacked_Dchi2 = _np.take(Dchi2,whacked_indices,axis=1) # (K,m,N) where m == len(whacked_indices)
#
#    grad = -1.0 * _np.sum(whacked_Dchi2,axis=(0,1)) # (N) after summing over gate strings and spam labels
#    dx = whackWith * grad / _np.dot(grad,grad) # direction in gateset space of direction to move to *decrease* the chi2
#                                               #  of the desired base string by whackWith
#    delta = _np.sum( _np.dot(Dchi2,dx), axis=0 ) # sum{(K,M), axis=1} ==> (M); the change in chi2 for each gateString
#                                                 #   as a result of a unit decrease in the chi2 of the base string
#
#    def mx_fn(gateStr,x,y):
#        # LEXICOGRAPHICAL VS MATRIX ORDER
#        if gateStr is None: return _np.nan * _np.zeros( (len(effectStrs),len(prepStrs)), 'd')
#
#        if gatestring_filters is not None:
#            ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
#            for j,effectStr in enumerate(effectStrs):
#                for i,prepStr in enumerate(prepStrs):
#                    s = prepStr + gateStr + effectStr
#                    if s in gatestring_filters[(x,y)] \
#                            and s in allGatestringsUsedInChi2Opt:
#                        ret[j,i] = delta[allGatestringsUsedInChi2Opt.index(s)]
#            return ret
#
#        elif fidpair_filters is not None:
#            ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
#            for i,j in fidpair_filters[(x,y)]:
#                s = prepStrs[i] + gateStr + effectStrs[j]
#                if s in allGatestringsUsedInChi2Opt:
#                    ret[j,i] = delta[ allGatestringsUsedInChi2Opt.index(s) ]
#            return ret
#
#        else:
#            return _np.array( [ [ delta[ allGatestringsUsedInChi2Opt.index(prepStr + gateStr + effectStr) ]
#                                  for prepStr in prepStrs  ] for effectStr in effectStrs ] )
#
#
#    xvals,yvals,subMxs,n_boxes,dof = _computeSubMxs(xvals,yvals,xy_gatestring_dict,mx_fn,sumUp)
#    max_abs = max([ _np.max(_np.abs(_np.nan_to_num(subMxs[iy][ix])))
#                    for ix in range(len(xvals))
#                    for iy in range(len(yvals)) ])
#    if max_abs == 0: max_abs = 1e-6 # pick a nonzero value if all entries are zero or nan
#    m = -max_abs if m is None else m
#    M = +max_abs if M is None else M
#    stdcmap = StdColormapFactory('div', n_boxes=n_boxes, vmin=m, vmax=M, dof=dof, midpoint=0)
#    return generate_boxplot( xvals, yvals, xy_gatestring_dict, subMxs, stdcmap, xlabel, ylabel,
#                            scale,prec,title,sumUp,boxLabels,histogram,histBins,save_to,ticSize,
#                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$" )
#
#
#
#def whack_a_logl_mole_boxplot( gatestringToWhack, allGatestringsUsedInLogLOpt,
#                               xvals, yvals, xy_gatestring_dict, dataset,
#                               gateset, strs, xlabel="", ylabel="", m=None,
#                               M=None, scale=1.0, prec='compact',
#                               title="Whack a log(L) Mole", sumUp=False,
#                               boxLabels=True, histogram=False, histBins=50,
#                               minProbClipForWeighting=1e-4, save_to=None,
#                               ticSize=20, whackWith=10.0, invert=False,
#                               fidpair_filters=None, gatestring_filters=None,
#                               gateLabelAliases=None):
#    """
#    Create a box plot indicating how the log-likelihood would change if the log(L)
#      of one base gate string blocks were forced to be smaller ("whacked").
#
#    Creates a color box plot which displays the change in log(L) caused by
#      changing the gate set parameters such that the log(L) of gatestringToWhack's
#      (x,y) block decreases by whackWith.  This changes the gate set along
#      the direction of parameter space given by the gradient of log(L) restricted
#      to only those gatestrings in gatestringToWhack's block, and the the
#      displayed difference in log(L) values are based on the linear interpolation
#      of the full gradient of log(L) after this change.
#
#    Parameters
#    ----------
#    gatestringToWhack : GateString or tuple
#        The **base** gate sequence for which log(L) will be decreased.
#
#    allGatestringsUsedInLogLOpt : list of GateStrings or tuples
#        List of all the gate strings used to form the total log(L) that is being decreased.
#
#    xvals, yvals : list
#        List of x and y values. Elements can be any hashable quantity, and will be converted
#        into x and y tic labels.  Tuples of strings are converted specially for nice latex
#        rendering of gate strings.
#
#    xy_gatestring_dict : dict
#        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
#        a gate string can either be a GateString object or a tuple of gate labels.  Provides
#        the mapping between x,y pairs and gate strings.  None values are allowed, and
#        indicate that there is not data for that x,y pair and nothing should be plotted.
#
#    dataset : DataSet
#        The data used to specify frequencies and counts
#
#    gateset : GateSet
#        The gate set used for computing probabilities
#
#    strs : 2-tuple
#        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)
#
#    xlabel, ylabel : str, optional
#        X and Y axis labels
#
#    m, M : float, optional
#        Min and max values of the color scale.
#
#    scale : float, optional
#        Scaling factor to adjust the size of the final figure.
#
#    prec : int, optional
#        Precision for box labels.  Allowed values are:
#          'compact' = round to nearest whole number using at most 3 characters
#          'compacthp' = show as much precision as possible using at most 3 characters
#          int >= 0 = fixed precision given by int
#          int <  0 = number of significant figures given by -int
#
#    title : string, optional
#        Plot title (latex can be used)
#
#    sumUp : bool, optional
#        False displays each matrix element as it's own color box
#        True sums the elements of each (x,y) matrix and displays
#        a single color box for the sum.
#
#    boxLabels : bool, optional
#        Whether box labels are displayed.  It takes much longer to
#        generate the figure when this is set to True.
#
#    histogram : bool, optional
#        Whether a histogram of the matrix element values or summed matrix
#        values (depending on sumUp) should also be computed and displayed.
#
#    histBins : int, optional
#        The number of bins to use in the histogram.
#
#    minProbClipForWeighting : float, optional
#        defines the minimum probability clipping for the log(L) function.
#
#    save_to : str, optional
#        save figure to this filename (usually ending in .pdf)
#
#    ticSize : int, optional
#        size of tic marks
#
#    whackWith : float, optional
#        the total amount to decrease chi^2 by.  This number just sets the
#        overall scale of the numbers displayed, since the extrapolation is
#        linear.
#
#    invert : bool, optional
#        If True, invert the nesting order of the nested color box plot (applicable
#        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
#        the x and y axes.
#
#    fidpair_filters : dict, optional
#        If not None, a dictionary whose keys are (x,y) tuples and whose values
#        are lists of (iRhoStr,iEStr) tuples specifying a subset of all the
#        prepStr,effectStr pairs to include in the plot for each particular
#        (x,y) sub-block.
#
#    gatestring_filters : dict, optional
#        If not None, a dictionary whose keys are (x,y) tuples and whose
#        values are lists of GateString objects specifying which elements should
#        be computed and displayed in the (x,y) sub-block of the plot.
#
#    gateLabelAliases : dictionary, optional
#        Dictionary whose keys are gate label "aliases" and whose values are tuples
#        corresponding to what that gate label should be expanded into before querying
#        the dataset. Defaults to the empty dictionary (no aliases defined)
#        e.g. gateLabelAliases['Gx^3'] = ('Gx','Gx','Gx')
#
#
#    Returns
#    -------
#    rptFig : ReportFigure
#        The encapsulated matplotlib figure that was generated.  Extra figure
#        info is a dict with keys:
#
#        nUsedXs : int
#            The number of used X-values, proportional to the overall final figure width
#        nUsedYs : int
#            The number of used Y-values, proportional to the overall final figure height
#    """
#
#    #We want the derivative of 2*Delta_LogL = 2 * sum_i N_i*(f_i*log(f_i/p_i) + (p_i-f_i))  (i over gatestrings & spam labels)
#    # and the ability to separate the 2*Delta_LogL of just "gatestringToWhack" (sandwiched with strs, optionally)
#    # This latter derivative (w.r.t gateset params) gives the direction in gateset space to move to reduce
#    #   the "whacked" string(s) 2*Delta_LogL.  Applying this direction to the full 2*Delta_LogL (or to other base strings
#    #   sandwiched with strs) will give the relative change in the 2*Delta_LogL for these strings if the whacked
#    #   string(s) was in fact whacked.
#    # D(2*Delta_LogL) = sum_i 2* N_i * [ -f_i/p_i + 1.0 ] * dp_i
#
#    prepStrs, effectStrs = strs
#    spamLabels = gateset.get_spam_labels() #this list fixes the ordering of the spam labels
#    spam_lbl_rows = { sl:i for (i,sl) in enumerate(spamLabels) }
#    vec_gs_len = gateset.num_params()
#      #Note: assumes *all* gateset params vary, which may not be what we always want (e.g. for TP-constrained analyses)
#
#    N      = _np.empty( len(allGatestringsUsedInLogLOpt) )
#    f      = _np.empty( (len(spamLabels),len(allGatestringsUsedInLogLOpt)) )
#    probs  = _np.empty( (len(spamLabels),len(allGatestringsUsedInLogLOpt)) )
#    dprobs = _np.empty( (len(spamLabels),len(allGatestringsUsedInLogLOpt),vec_gs_len) )
#
#    ds_gatestrings = _tools.find_replace_tuple_list(allGatestringsUsedInLogLOpt,gateLabelAliases)
#    for (i,gateStr) in enumerate(ds_gatestrings):
#        N[i] = float(dataset[gateStr].total())
#        for k,sl in enumerate(spamLabels):
#            f[k,i] = dataset[gateStr].fraction(sl)
#
#    evTree = gateset.bulk_evaltree(allGatestringsUsedInLogLOpt)
#    gateset.bulk_fill_dprobs(dprobs, spam_lbl_rows, evTree, prMxToFill=probs) # spamlabel, gatestring, gsParam
#
#    pos_probs = _np.maximum(probs, minProbClipForWeighting) #make sure all probs are positive? TODO: make this fn handle minProbClip like do_mlgst does...
#    DlogL = 2 * (N[None,:] * (1.0 - f/pos_probs))[:,:,None] * dprobs # (K,M,1) * (K,M,N)
#
#    # LEXICOGRAPHICAL VS MATRIX ORDER
#
#    #Since we don't know which (x,y) pair the gatestringToWhack is associated with,
#    # we try to wack *all* possible fiducial pairs.
#    gatestringsToWhack = [ (prepStr + gatestringToWhack + effectStr) for prepStr in prepStrs for effectStr in effectStrs ]
#
#    whacked_indices = []
#    for s in gatestringsToWhack:
#        try:  whacked_indices.append(allGatestringsUsedInLogLOpt.index(s))
#        except ValueError: pass #just ignore gatestrings that aren't available
#    whacked_DlogL = _np.take(DlogL,whacked_indices,axis=1) # (K,m,N) where m == len(whacked_indices)
#
#    grad = -1.0 * _np.sum(whacked_DlogL,axis=(0,1)) # (N) after summing over gate strings and spam labels
#    dx = whackWith * grad / _np.dot(grad,grad) # direction in gateset space of direction to move to *decrease* the 2*Delta_LogL
#                                               #  of the desired base string by whackWith
#    delta = _np.sum( _np.dot(DlogL,dx), axis=0 ) # sum{(K,M), axis=1} ==> (M); the change in 2*Delta_LogL for each gateString
#                                                 #   as a result of a unit decrease in the 2*Delta_LogL of the base string
#
#    def mx_fn(gateStr,x,y):
#        # LEXICOGRAPHICAL VS MATRIX ORDER
#        if gateStr is None: return _np.nan * _np.zeros( (len(effectStrs),len(prepStrs)), 'd')
#
#        if gatestring_filters is not None:
#            ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
#            for j,effectStr in enumerate(effectStrs):
#                for i,prepStr in enumerate(prepStrs):
#                    s = prepStr + gateStr + effectStr
#                    if s in gatestring_filters[(x,y)] \
#                            and s in allGatestringsUsedInLogLOpt:
#                        ret[j,i] = delta[allGatestringsUsedInLogLOpt.index(s)]
#            return ret
#
#        elif fidpair_filters is not None:
#            ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
#            for i,j in fidpairs_filters[(x,y)]:
#                s = prepStrs[i] + gateStr + effectStrs[j]
#                if s in allGatestringsUsedInLogLOpt:
#                    ret[j,i] = delta[ allGatestringsUsedInLogLOpt.index(s) ]
#            return ret
#
#        else:
#            return _np.array( [ [ delta[ allGatestringsUsedInLogLOpt.index(prepStr + gateStr + effectStr) ]
#                                  for prepStr in prepStrs ] for effectStr in effectStrs ] )
#
#
#    xvals,yvals,subMxs,n_boxes,dof = _computeSubMxs(xvals,yvals,xy_gatestring_dict,mx_fn,sumUp)
#    max_abs = max([ _np.max(_np.abs(_np.nan_to_num(subMxs[iy][ix])))
#                    for ix in range(len(xvals))
#                    for iy in range(len(yvals)) ])
#    if max_abs == 0: max_abs = 1e-6 # pick a nonzero value if all entries are zero or nan
#    m = -max_abs if m is None else m
#    M = +max_abs if M is None else M
#    stdcmap = StdColormapFactory('div', n_boxes=n_boxes, vmin=m, vmax=M, dof=dof, midpoint=0)
#    return generate_boxplot( xvals, yvals, xy_gatestring_dict, subMxs, stdcmap, xlabel, ylabel,
#                            scale,prec,title,sumUp,boxLabels,histogram,histBins,save_to,ticSize,
#                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$" )
