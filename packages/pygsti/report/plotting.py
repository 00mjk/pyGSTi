#*****************************************************************
#    pyGSTi 0.9:  Copyright 2015 Sandia Corporation              
#    This Software is released under the GPL license detailed    
#    in the file "license.txt" in the top-level pyGSTi directory 
#*****************************************************************
""" Functions for generating plots and computing chi^2 """

from __future__ import division
import numpy as _np
import matplotlib.pyplot as _plt
import matplotlib as _matplotlib
import os as _os
from matplotlib.ticker import AutoMinorLocator as _AutoMinorLocator
from matplotlib.ticker import FixedLocator as _FixedLocator
from scipy.stats import chi2 as _chi2

from .. import algorithms as _alg
from .. import tools as _tools
from .. import construction as _construction
from .. import objects as _objs

from figure import ReportFigure as _ReportFigure


def total_count_matrix( gateString, dataset, strs, fidPairs=None):
    """
    Computes the total count matrix for a base gatestring.

    Parameters
    ----------
    gateString : tuple of gate labels
        The gate sequence that is sandwiched between each effectStr and prepStr

    dataset : DataSet
        The data used to specify the counts

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other values are set to NaN.

    Returns
    -------
    numpy array of shape (M,N)
        total count values (sum of count values for each SPAM label)
        corresponding to gate sequences where gateString is sandwiched 
        between the specified set of N prepSpec and M effectSpec gate strings.
    """
    prepStrs, effectStrs = strs # LEXICOGRAPHICAL VS MATRIX ORDER
    if fidPairs is None:
        mxlst = []
        for effectStr in effectStrs:
            rowLst = []
            for prepStr in prepStrs:
                gstr = prepStr + gateString + effectStr
                if gstr in dataset: rowLst.append( dataset[gstr].total() )
                else: rowLst.append( _np.nan )
            mxlst.append(rowLst)
        return _np.array( mxlst )
    else:
        ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
        for i,j in fidPairs:
            gstr = prepStrs[i] + gateString + effectStrs[j]
            if gstr in dataset: ret[j,i] = dataset[ gstr ].total()
        return ret


def count_matrix( gateString, dataset, spamlabel, strs, fidPairs=None ):
    """
    Computes spamLabel's count matrix for a base gatestring.

    Parameters
    ----------
    gateString : tuple of gate labels
        The gate sequence that is sandwiched between each effectStr and prepStr

    dataset : DataSet
        The data used to specify the counts

    spamLabel : string
        The spam label to extract counts for, e.g. 'plus'

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other values are set to NaN.

    Returns
    -------
    numpy array of shape ( len(effectStrs), len(prepStrs) )
        count values corresponding to spamLabel and gate sequences 
        where gateString is sandwiched between the each (effectStr,prepStr) pair.
    """
    prepStrs, effectStrs = strs # LEXICOGRAPHICAL VS MATRIX ORDER
    if fidPairs is None:
        mxlst = []
        for effectStr in effectStrs:
            rowLst = []
            for prepStr in prepStrs:
                gstr = prepStr + gateString + effectStr
                if gstr in dataset: rowLst.append( dataset[gstr][spamlabel] )
                else: rowLst.append( _np.nan )
            mxlst.append(rowLst)
        return _np.array( mxlst )
    else:
        ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
        for i,j in fidPairs:
            gstr = prepStrs[i] + gateString + effectStrs[j]
            if gstr in dataset: ret[j,i] = dataset[ gstr ][spamlabel]
        return ret




def frequency_matrix( gateString, dataset, spamlabel, strs, fidPairs=None):
    """
    Computes spamLabel's frequency matrix for a base gatestring.

    Parameters
    ----------
    gateString : tuple of gate labels
        The gate sequence that is sandwiched between each effectStr and prepStr

    dataset : DataSet
        The data used to specify the frequencies

    spamLabel : string
        The spam label to extract frequencies for, e.g. 'plus'

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other values are set to NaN.

    Returns
    -------
    numpy array of shape ( len(effectStrs), len(prepStrs) )
        frequency values corresponding to spamLabel and gate sequences 
        where gateString is sandwiched between the each (effectStr,prepStr) pair.
    """
    return count_matrix( gateString, dataset, spamlabel, strs, fidPairs) / total_count_matrix( gateString, dataset, strs, fidPairs)


def probability_matrix( gateString, gateset, spamlabel, strs, fidPairs=None):
    """
    Computes spamLabel's probability matrix for a base gatestring.

    Parameters
    ----------
    gateString : tuple of gate labels
        The gate sequence that is sandwiched between each effectStr and prepStr

    gateset : GateSet
        The gate set used to specify the probabilities

    spamLabel : string
        The spam label to extract probabilities for, e.g. 'plus'

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other values are set to NaN.

    Returns
    -------
    numpy array of shape ( len(effectStrs), len(prepStrs) )
        probability values corresponding to spamLabel and gate sequences 
        where gateString is sandwiched between the each (effectStr,prepStr) pair.
    """
    prepStrs, effectStrs = strs # LEXICOGRAPHICAL VS MATRIX ORDER
    if fidPairs is None:
        return _np.array( [ [ gateset.pr( spamlabel, prepStr + gateString + effectStr ) for prepStr in prepStrs ] for effectStr in effectStrs ] )
    else:
        ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
        for i,j in fidPairs:
            ret[j,i] = gateset.pr( spamlabel, prepStrs[i] + gateString + effectStrs[j] )
        return ret




def chi2_matrix( gateString, dataset, gateset, strs, minProbClipForWeighting=1e-4, fidPairs=None):
    """
    Computes the chi^2 matrix for a base gatestring.

    Parameters
    ----------
    gateString : tuple of gate labels
        The gate sequence that is sandwiched between each effectStr and prepStr

    dataset : DataSet
        The data used to specify frequencies and counts

    gateset : GateSet
        The gate set used to specify the probabilities and SPAM labels

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight (see chi2fn).

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other values are set to NaN.

    Returns
    -------
    numpy array of shape ( len(effectStrs), len(prepStrs) )
        chi^2 values corresponding to gate sequences where 
        gateString is sandwiched between the each (effectStr,prepStr) pair.
        (i.e. element_ij = gate_string_chi2( prepStrs[j] + gateString + effectStrs[i])
    """
    prepStrs, effectStrs = strs
    chiSqMx = _np.zeros( (len(effectStrs),len(prepStrs)), 'd')
    if gateString is None: return _np.nan*chiSqMx
    cntMx  = total_count_matrix(  gateString, dataset, strs, fidPairs)
    for sl in gateset.get_spam_labels():
        probMx = probability_matrix( gateString, gateset, sl, strs, fidPairs)
        freqMx = frequency_matrix(   gateString, dataset, sl, strs, fidPairs)
        chiSqMx += _tools.chi2fn( cntMx, probMx, freqMx,
                                     minProbClipForWeighting)
    return chiSqMx


def logl_matrix( gateString, dataset, gateset, strs, minProbClip=1e-6, fidPairs=None):
    """
    Computes the log-likelihood matrix of 2*( log(L)_upperbound - log(L) ) 
    values for a base gatestring.

    Parameters
    ----------
    gateString : tuple of gate labels
        The gate sequence that is sandwiched between each effectStr and prepStr

    dataset : DataSet
        The data used to specify frequencies and counts

    gateset : GateSet
        The gate set used to specify the probabilities and SPAM labels

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    minProbClip : float, optional
        defines the minimum probability "patch-point" of the log-likelihood function.

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other values are set to NaN.

    Returns
    -------
    numpy array of shape ( len(effectStrs), len(prepStrs) )
        logl values corresponding to gate sequences where 
        gateString is sandwiched between the each (effectStr,prepStr) pair.
    """
    prepStrs, effectStrs = strs
    logLMx = _np.zeros( (len(effectStrs),len(prepStrs)), 'd')
    if gateString is None: return _np.nan*logLMx
    cntMx  = total_count_matrix(  gateString, dataset, strs, fidPairs)
    for sl in gateset.get_spam_labels():
        probMx = probability_matrix( gateString, gateset, sl, strs, fidPairs)
        freqMx = frequency_matrix(   gateString, dataset, sl, strs, fidPairs)
        logLMx += _tools.two_delta_loglfn( cntMx, probMx, freqMx, minProbClip)
    return logLMx



def small_eigval_err_rate(sigma, dataset, directGSTgatesets):
    """
    Compute per-gate error rate.

    The per-gate error rate, extrapolated from the smallest eigvalue 
    of the Direct GST estimate of the given gate string sigma.

    Parameters
    ----------
    sigma : GateString or tuple of gate labels
        The gate sequence that is used to estimate the error rate

    dataset : DataSet
        The dataset used obtain gate string frequencies

    directGSTgatesets : dictionary of GateSets
        A dictionary with keys = gate strings and
        values = GateSets.

    Returns
    -------
    float
        the approximate per-gate error rate.
    """
    if sigma is None: return _np.nan # in plot processing, "None" gatestrings = no plot output = nan values
    gs_direct = directGSTgatesets[sigma]
    minEigval = min(abs(_np.linalg.eigvals( gs_direct.gates["GsigmaLbl"] )))
    return 1.0 - minEigval**(1.0/max(len(sigma),1)) # (approximate) per-gate error rate; max averts divide by zero error

def besttxtcolor( x, cmap, norm ):
    """ 
    Determinining function for whether text should be white or black

    Parameters
    ----------
    x : float
        Value of the cell in question
    cmap : matplotlib colormap
        Colormap assigning colors to the cells
    norm : matplotlib normalizer
        Function to map cell values to the interval [0, 1] for use by a
        colormap

    Returns
    -------
    {"white","black"}
    """
    cell_color = cmap(norm(x))
    R, G, B = cell_color[:3]
    # Perceived brightness calculation from http://alienryderflex.com/hsp.html
    P = _np.sqrt(0.299*R**2 + 0.587*G**2 + 0.114*B**2)
    return "black" if 0.5 <= P else "white"
    
class LinLogNorm(_matplotlib.colors.Normalize):
    def __init__(self, trans=None, vmin=None, vmax=None, clip=False):
        super(LinLogNorm, self).__init__(vmin=vmin, vmax=vmax, clip=clip)
        self.trans = trans
            
    def inverse(self, value):
        norm_trans = super(LinLogNorm, self).__call__(self.trans)
        deltav = self.vmax - self.vmin
        return_value = _np.where(_np.greater(0.5, value),
                                 2*value*(self.trans - self.vmin) + self.vmin,
                                 deltav*_np.power(norm_trans, 2*(1 - value)))
        if return_value.shape==():
            return return_value.item()
        else:
            return return_value.view(_np.ma.MaskedArray)
        
    def __call__(self, value, clip=None):
        lin_norm_value = super(LinLogNorm, self).__call__(value)
        if self.trans is None:
            self.trans = (self.vmax - self.vmin)/10 + self.vmin
        norm_trans = super(LinLogNorm, self).__call__(self.trans)
        log10_norm_trans = _np.log10(norm_trans)
        with _np.errstate(divide='ignore'):
            # Ignore the division-by-zero error that occurs when 0 is passed to
            # log10 (the resulting NaN is filtered out by the where and is
            # harmless).
            return_value = _np.where(_np.greater(norm_trans, lin_norm_value),
                                     lin_norm_value/(2*norm_trans),
                                     (log10_norm_trans -
                                      _np.log10(lin_norm_value)) /
                                     (2*log10_norm_trans) + 0.5)
        if return_value.shape==():
            return return_value.item()
        else:
            return return_value.view(_np.ma.MaskedArray)

def splice_cmaps(cmaps, name=None, splice_points=None):
    """
    Take a list of cmaps and create a new cmap that joins them at specified
    points.

    Parameters
    ----------
    cmaps : list of matplotlib cmaps
        The colormaps ordered according to how they should appear in the final
        colormap

    name : string
        The name for the colormap. If no name is given, the name
        'spliced_cmap1name_cmap2name_...' is assigned to the colormap.

    splice_points : ordered list of floats in (0, 1), optional
        The transition points when one colormap should end and the next should
        begin. Should have one less point than the number of cmaps provided. If
        no list is provided, the splice points will be arranged to split the
        interval (0, 1) up into equal seqments.

    Returns
    -------
    A cmap combining the provided cmaps
    """
    if name is None:
        name = '_'.join(['spliced'] + [cmap.name for cmap in cmaps])

    n_cmaps = len(cmaps)

    if splice_points is None:
        splice_points = _np.linspace(0, 1, n_cmaps + 1)[1:-1].tolist()

    n_sps = len(splice_points)

    if n_sps != n_cmaps - 1:
        raise ValueError(('The number of splice points, {0}, is not one less' +
            ' than the number of colormaps, {1}.').format(n_sps, n_cmaps))

    ranges = list(zip([0.0] + splice_points, splice_points + [1.0]))

    red_list = []
    green_list = []
    blue_list = []
    alpha_list = []

    # First segment
    cmap = cmaps[0]
    N = cmap.N
    low_val, high_val = ranges[0]
    input_values = _np.linspace(0.0, 1.0, N)
    scaled_values = _np.linspace(low_val, high_val, N)
    colors = cmap(input_values)
    for color, value in zip(colors[:-1], scaled_values[:-1]):
        r, g, b, a = color
        red_list.append((value, r, r))
        green_list.append((value, g, g))
        blue_list.append((value, b, b))
        alpha_list.append((value, a, a))

    # Middle segments
    for cmap, prev_cmap, rng in zip(cmaps[1:-1], cmaps[:-2], ranges[1:-1]):
        N = cmap.N
        low_val, high_val = rng
        input_values = _np.linspace(0.0, 1.0, N)
        scaled_values = _np.linspace(low_val, high_val, N)
        colors = cmap(input_values)
        prev_r, prev_g, prev_b, prev_a = prev_cmap(1.0)
        r, g, b, a = colors[0]
        red_list.append((low_val, prev_r, r))
        green_list.append((low_val, prev_g, g))
        blue_list.append((low_val, prev_b, b))
        alpha_list.append((low_val, prev_a, a))
        for color, value in zip(colors[1:-1], scaled_values[1:-1]):
            r, g, b, a = color
            red_list.append((value, r, r))
            green_list.append((value, g, g))
            blue_list.append((value, b, b))
            alpha_list.append((value, a, a))

    # Final segment
    cmap = cmaps[-1]
    prev_cmap = cmaps[-2]
    N = cmap.N
    low_val, high_val = ranges[-1]
    input_values = _np.linspace(0.0, 1.0, N)
    scaled_values = _np.linspace(low_val, high_val, N)
    colors = cmap(input_values)
    prev_r, prev_g, prev_b, prev_a = prev_cmap(1.0)
    r, g, b, a = colors[0]
    red_list.append((low_val, prev_r, r))
    green_list.append((low_val, prev_g, g))
    blue_list.append((low_val, prev_b, b))
    alpha_list.append((low_val, prev_a, a))
    for color, value in zip(colors[1:], scaled_values[1:]):
        r, g, b, a = color
        red_list.append((value, r, r))
        green_list.append((value, g, g))
        blue_list.append((value, b, b))
        alpha_list.append((value, a, a))

    cdict = {'red': red_list, 'green': green_list, 'blue': blue_list,
             'alpha': alpha_list}
    spliced_cmap = _matplotlib.colors.LinearSegmentedColormap(name, cdict)

    # return name, splice_points, cdict, spliced_cmap

    return spliced_cmap

def make_linear_cmap(start_color, final_color, name=None):
    """
    Make a color map that simply linearly interpolates between a start color
    and final color in RGB(A) space.

    Parameters
    ----------
    start_color : 3- (or 4-) tuple
        The (r, g, b[, a]) values for the start color.

    final_color : 3- (or 4-) tuple
        The (r, g, b[, a]) values for the final color.

    name : string
        A name for the colormap. If not provided, a name will be constructed
        from the colors at the two endpoints.

    Returns
    -------
    A cmap that interpolates between the endpoints in RGB(A) space.
    """
    labels = ['red', 'green', 'blue', 'alpha']
    cdict = {label: [(0, start_color[idx], start_color[idx]),
                     (1, final_color[idx], final_color[idx])]
             for label, idx in zip(labels, range(len(start_color)))}

    if name is None:
        name = 'linear_' + str(start_color) + '-' + str(final_color)

    return _matplotlib.colors.LinearSegmentedColormap(name, cdict)

def get_transition(N, eps=.1):
    '''
    Computes the transition point for the LinLogNorm class.

    Parameters
    -------------

    N: number of chi2_1 random variables, integer
    eps: The quantile, float

    Returns
    ---------

    trans: An approximate 1-eps quantile for the maximum of N chi2_1 random
    variables
    '''

    trans = _np.ceil(_chi2.ppf(1 - eps / N, 1))

    return trans

class StdColormapFactory(object):
    """
    Class used to create a standard GST colormap.
    """

    def __init__(self, kind, vmin=None, vmax=None, n_boxes=None, linlg_pcntle=.05):

        assert kind in ['linlog', 'div', 'seq'],\
            'Please instantiate the StdColormapFactory with a valid kind of colormap.'

        if kind != 'linlog':
            if (vmin is None) or (vmax is None):
                raise ValueError('vmin and vmax must both not be None for non-linlog colormap types.')
        else:
            if n_boxes is None:
                raise ValueError('linlog colormap type requires a non-None vlaue for n_boxes.')

        self.kind = kind
        self.vmin = vmin
        self.vmax = vmax
        self.N = n_boxes
        self.percentile = linlg_pcntle

    def get_norm(self):
        #Creates the normalization class
        if self.kind != 'linlog':
            norm = _matplotlib.colors.Normalize(vmin=self.vmin, vmax=self.vmax, clip=False)
        else:
            linlog_trans = _np.ceil(_chi2.ppf(1 - self.percentile / self.N, 1))
            norm = LinLogNorm(trans=linlog_trans)

        return norm

    def get_cmap(self):
        #Creates the colormap
        if self.kind == 'seq':
            cmap = _matplotlib.cm.get_cmap('Greys')
        elif self.kind == 'div':
            cmap = _matplotlib.cm.get_cmap('bwr')
        else:
            # Colors ranging from white to gray on [0.0, 0.5) and pink to red on
            # [0.5, 1.0] such that the perceived brightness of the pink matches the
            # gray.
            grayscale_cmap = make_linear_cmap((1, 1, 1), (0.5, 0.5, 0.5))
            red_cmap = make_linear_cmap((.698, .13, .133), (1, 0, 0))
            cmap = splice_cmaps([grayscale_cmap, red_cmap], 'linlog')

        cmap.set_bad('w',1)

        return cmap

def make_cmap_norm(kind, vmin=None, vmax=None, n_boxes=None, linlg_pcntle=.05):
    """
    Creates an appropriate colormap for the plots

    Parameters
    -----------
    kind: string
        What kind of colormap is to be used. Acceptable inputs include
        'linlog', 'seq', and 'div'.

    vmin, vmax: float

    linlg_pcntle: float, optional
        Specifies where the break from linear to logarithmic
        Specifies the (1-ling_pcntle) percentile. Used when kind='linlog'

    Returns
    ---------
    cmap, norm: The colormap and normalization
    """

    assert kind in ['linlog', 'div', 'seq'], 'Please enter a valid kind of colormap to create.'

    if kind != 'linlog':
        if (vmin is None) or (vmax is None):
            raise ValueError("For non linlog-type colormaps, vmin and vmax must be specified.")
    else:
        if vmin is not None:
            print('vmin not required for linlog-type colormaps. Ignoring.')
        elif vmax is not None:
            print('vmax not required for linlog-type colormaps. Ignoring.')
        if n_boxes is None:
            raise ValueError("The number of boxes being plotted must be specified when the colormap\
                type is linlog.")
        if n_boxes == 0:
            raise ValueError("n_boxes being plotted must be non-zero when the colormap\
                type is linlog.")

    #Creates the normalization class
    if kind != 'linlog':
        norm = _matplotlib.colors.Normalize(vmin=vmin, vmax=vmax, clip=False)
    else:
        linlog_trans = _np.ceil(_chi2.ppf(1 - linlg_pcntle / n_boxes, 1))
        norm = LinLogNorm(trans=linlog_trans)

    #Creates the colormap
    if kind == 'seq':
        cmap = _matplotlib.cm.get_cmap('Greys')
    elif kind == 'div':
        cmap = _matplotlib.cm.get_cmap('bwr')
    else:
        # Colors ranging from white to gray on [0.0, 0.5) and pink to red on
        # [0.5, 1.0] such that the perceived brightness of the pink matches the
        # gray.
        grayscale_cmap = make_linear_cmap((1, 1, 1), (0.5, 0.5, 0.5))
        red_cmap = make_linear_cmap((.698, .13, .133), (1, 0, 0))
        cmap = splice_cmaps([grayscale_cmap, red_cmap], 'linlog')

    cmap.set_bad('w',1)
    return cmap, norm

def color_boxplot(plt_data, cmapFactory, title=None, xlabels=None, ylabels=None, xtics=None, ytics=None,
                 colorbar=True, fig=None, axes=None, size=None, prec=0, boxLabels=True,
                 xlabel=None, ylabel=None, save_to=None, ticSize=14, grid=False):
    """
    Create a color box plot.

    Creates a figure composed of colored boxes and possibly labels.

    Parameters
    ----------
    plt_data : numpy array
        A 2D array containing the values to be plotted.

    cmapFactory: ColormapFactory class
        An instance of a ColormapFactory class

    title : string, optional
        Plot title (latex can be used)

    xlabels, ylabels : list of strings, optional
        Tic labels for x and y axes.  If both are None, then tics are not drawn.

    xtics, ytics : list or array of floats, optional
        Values of x and y axis tics.  If None, then half-integers from 0.5 to 
        0.5 + (nCols-1) or 0.5 + (nRows-1) are used, respectively.

    colorbar : bool, optional
        Whether to display a colorbar or not.

    fig, axes : matplotlib figure and axes, optional
        If non-None, use these figure and axes objects instead of creating new ones
        via fig,axes = pyplot.supblots()

    size : 2-tuple, optional
        The width and heigh of the final figure in inches.

    prec : int or {'compact','compacthp'}, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    xlabel, ylabel : str, optional
        X and Y axis labels

    save_to : str, optional
        save figure as this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    grid : bool, optional
        Whether or not grid lines should be displayed.
    
    Returns
    -------
    ReportFigure
        The encapsulated matplotlib figure that was generated
    """
    if axes is None: fig,axes = _plt.subplots()  # create a new figure if no axes are given

    cmap, norm = cmapFactory.get_cmap(), cmapFactory.get_norm()

    masked_data = _np.ma.array (plt_data, mask=_np.isnan(plt_data))

    heatmap = axes.pcolormesh( masked_data, cmap=cmap, norm=norm)

    if size is not None and fig is not None:
        fig.set_size_inches(size[0],size[1]) # was 12,8 for "super" color plot

    axes.set_xlim(0,plt_data.shape[1])
    axes.set_ylim(0,plt_data.shape[0])

    if xlabels is not None:
        if xtics is None:
            xtics = _np.arange(plt_data.shape[1])+0.5
        axes.set_xticks(xtics, minor=False)
        axes.set_xticklabels( xlabels,rotation=0, fontsize=ticSize )
    if ylabels is not None:
        if ytics is None: 
            ytics = _np.arange(plt_data.shape[0])+0.5
        axes.set_yticks(ytics, minor=False)
        axes.set_yticklabels( ylabels, fontsize=ticSize )

    if grid:
        def get_minor_tics(t):
            return [ (t[i]+t[i+1])/2.0 for i in range(len(t)-1) ]
        axes.set_xticks(get_minor_tics(xtics), minor=True)
        axes.set_yticks(get_minor_tics(ytics), minor=True)
        axes.grid(which='minor', axis='both', linestyle='-', linewidth=2)


    if xlabels is None and ylabels is None:
        axes.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off') #white tics
    else:
        axes.tick_params(top='off', bottom='off', left='off', right='off')

    if title is not None:
        axes.set_title( title, fontsize=(ticSize+4) )

    if xlabel is not None:
        axes.set_xlabel( xlabel, fontsize=(ticSize+4) )

    if ylabel is not None:
        axes.set_ylabel( ylabel, fontsize=(ticSize+4) )

    def eformat(f, prec):
        if prec == 'compact' or prec == 'compacthp':
            if f < 0: 
                return "-" + eformat(-f,prec)

            if prec == 'compacthp':
                if f < 0.005: #can't fit in 2 digits; would just be .00, so just print "0"
                    return "0"
                if f < 1:
                    z = "%.2f" % f # print first two decimal places
                    if z.startswith("0."): return z[1:]  # fails for '1.00'; then thunk down to next f<10 case
                if f < 10:
                    return "%.1f" % f # print whole number and tenths

            if f < 100: 
                return "%.0f" % f # print nearest whole number if only 1 or 2 digits
            
            #if f >= 100, minimal scientific notation, such as "4e7", not "4e+07"
            s = "%.0e" % f
            try:
                mantissa, exp = s.split('e')
                exp = int(exp)
                if exp >= 100: return "B" #if number is too big to print
                if exp >= 10: return "*%d" % exp
                return "%se%d" % (mantissa, exp)
            except:
                return str(s)[0:3]

        elif type(prec) == int:
            if prec >= 0:
                return "%.*f" % (prec,f)
            else: 
                return "%.*g" % (-prec,f)
        else:
            return "%g" % f #fallback to general format

    if boxLabels:
        # Write values on colored squares
        for y in range(plt_data.shape[0]):
            for x in range(plt_data.shape[1]):
                if _np.isnan(plt_data[y, x]): continue
                axes.text(x + 0.5, y + 0.5, eformat(plt_data[y, x], prec),
                        horizontalalignment='center',
                        verticalalignment='center', color=besttxtcolor( plt_data[y,x], cmap, norm) )

    if colorbar:
        _plt.colorbar(heatmap)

    rptFig = _ReportFigure(axes)

    if save_to is not None:
        if len(save_to) > 0: #So you can pass save_to="" and figure will be closed but not saved to a file
            _plt.savefig(save_to, bbox_extra_artists=(axes,), bbox_inches='tight') #need extra artists otherwise axis labels get clipped
        if fig is not None: _plt.close(fig) #close the figure if we're saving it to a file

    return rptFig



def nested_color_boxplot(plt_data_list_of_lists, cmapFactory, title=None, xlabels=None, ylabels=None, xtics=None, ytics=None,
                       colorbar=True, fig=None, axes=None, size=None, prec=0, 
                       boxLabels=True, xlabel=None, ylabel=None, save_to=None, ticSize=14, grid=False):
    """
    Create a color box plot.

    Creates a figure composed of colored boxes and possibly labels.

    Parameters
    ----------
    plt_data_list_of_lists : list of lists of numpy arrays
        A complete square 2D list of lists, such that each element is a
        2D numpy array of the same size.

    cmapFactory: instance of the ColormapFactory class

    norm: matplotlib norm
        The norm to be used.

    title : string, optional
        Plot title (latex can be used)

    xlabels, ylabels : list of strings, optional
        Tic labels for x and y axes.  If both are None, then tics are not drawn.

    xtics, ytics : list or array of floats, optional
        Values of x and y axis tics.  If None, then half-integers from 0.5 to 
        0.5 + (nCols-1) or 0.5 + (nRows-1) are used, respectively.

    colorbar : bool, optional
        Whether to display a colorbar or not.

    fig, axes : matplotlib figure and axes, optional
        If non-None, use these figure and axes objects instead of creating new ones
        via fig,axes = pyplot.supblots()

    size : 2-tuple, optional
        The width and heigh of the final figure in inches.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    xlabel, ylabel : str, optional
        X and Y axis labels

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    grid : bool, optional
        Whether or not grid lines should be displayed.
    
    Returns
    -------
    ReportFigure
        The encapsulated matplotlib figure that was generated
    """

    #Assume a complete 2D rectangular list of lists, and that each element is a numpy array of the same size
    if len(plt_data_list_of_lists) == 0 or len(plt_data_list_of_lists[0]) == 0: return
    elRows,elCols = plt_data_list_of_lists[0][0].shape #nE,nr
    nRows = len(plt_data_list_of_lists)
    nCols = len(plt_data_list_of_lists[0])

    data = _np.zeros( ( elRows*nRows + (nRows-1), elCols*nCols + (nCols-1)) )
    for i in range(1,nRows):
        data[(elRows+1)*i-1:(elRows+1)*i,:] = _np.nan
    for j in range(1,nCols):
        data[:, (elCols+1)*j-1:(elCols+1)*j] = _np.nan

    for i in range(nRows):
        for j in range(nCols):
            data[(elRows+1)*i:(elRows+1)*(i+1)-1, (elCols+1)*j:(elCols+1)*(j+1)-1] = plt_data_list_of_lists[i][j]

    xtics = []; ytics = []
    for i in range(nRows):   ytics.append( float((elRows+1)*(i+0.5)) )
    for j in range(nCols):   xtics.append( float((elCols+1)*(j+0.5)) )

    return color_boxplot(data, cmapFactory, title, xlabels, ylabels, _np.array(xtics), _np.array(ytics),
                        colorbar, fig, axes, size, prec, boxLabels, xlabel, ylabel,
                        save_to, ticSize, grid)

def _computeSubMxs(xvals, yvals, xyGateStringDict, subMxCreationFn):
    subMxs = [ [ subMxCreationFn( xyGateStringDict[(x,y)] ) for x in xvals ] for y in yvals]
    return subMxs #Note: subMxs[y-index][x-index] is proper usage

def generate_boxplot( xvals, yvals, xyGateStringDict, subMxCreationFn, cmapFactory, xlabel="", ylabel="", scale=1.0, prec=0,
                     title='sub-mx', sumUp=False, interactive=False, boxLabels=True, histogram=False, histBins=50, save_to=None,
                     ticSize=20, invert=False, inner_x_labels=None, inner_y_labels=None, inner_x_label=None, inner_y_label=None,
                     grid=False):
    """
    Creates a view of nested box plot data (i.e. a matrix for each (x,y) pair).

    Given lists of x and y values, a dictionary to convert (x,y) pairs into gate strings,
    and a function to convert a "base" gate string into a matrix of floating point values,
    this function computes (x,y) => matrix data and displays it in one of two ways:

    1. As a full nested color box plot, showing all the matrix values individually
    2. As a color box plot containing the sum of the elements in the (x,y) matrix as
       the (x,y) box.

    A histogram of the values can also be computed and displayed.  Setting
    interactive == True allows the user to interactively change the color scale's min and
    max values.
    
    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xyGateStringDict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.
    
    subMxCreationFn : function
        A function that takes a singe gate string parameter and returns a matrix of values to 
        display.  If the function is passed None instead of a gate string, the function 
        should return an appropriately sized matrix of NaNs to indicate these elements should
        not be displayed.

    cmapFactory: instance of the ColormapFactory class

    norm: matplotlib norm
        The norm to be used.

    xlabel, ylabel : str, optional
        X and Y axis labels

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    inner_x_labels, inner_y_labels : list, optional
        Similar to xvals, yvals but labels for the columns and rows of the (x,y) matrices
        computed by subMxCreationFn.  Used when invert == True.

    grid : bool, optional
        Whether or not grid lines should be displayed.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Note that 
        figure extra info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """

    init_min_clip = 0
    init_max_clip = 10

    used_xvals = [ x for x in xvals if any([ (xyGateStringDict[(x,y)] is not None) for y in yvals]) ]
    used_yvals = [ y for y in yvals if any([ (xyGateStringDict[(x,y)] is not None) for x in xvals]) ]

    nXs,nYs = len(used_xvals),len(used_yvals)

    def val_filter(vals):  #filter to latex-ify gate strings.  Later add filter as a possible parameter
        formatted_vals = []
        for val in vals:
            if type(val) == tuple and all([type(el) == str for el in val]):
                if len(val) == 0:
                    formatted_vals.append(r"$\{\}$")
                else:
                    formatted_vals.append( "$" + "\\cdot".join([("\\mathrm{%s}" % el) for el in val]) + "$" )
            else:
                formatted_vals.append(val)
        return formatted_vals
                

    if interactive:
        from IPython.html import widgets
        from IPython.html.widgets import interact, fixed

    #Compute sub-matrices (which are either displayed as nested sub-boxes of plot or are summed)
    subMxs = _computeSubMxs(used_xvals, used_yvals, xyGateStringDict, subMxCreationFn)

    def str_to_float(s):
        if s is None or s == "None" or len(str(s)) == 0: return None
        else: return float(s)

    def sum_up_mx(mx):
        flat_mx = mx.flatten()
        if any([_np.isnan(x) for x in flat_mx]):
            if all([_np.isnan(x) for x in flat_mx]): 
                return _np.nan
            return sum(_np.nan_to_num(flat_mx)) #replace NaNs with zeros for purpose of summing (when there's at least one non-NaN)
        else:
            return sum(flat_mx)

    #Setup and create plotting functions
    if sumUp:
        subMxSums = _np.array( [ [ sum_up_mx(subMxs[iy][ix]) for ix in range(nXs) ] for iy in range(nYs) ], 'd' )
        if invert: print "Warning: cannot invert a summed-up plot.  Ignoring invert=True."

        def makeplot(min_clip, max_clip):
            minclip = str_to_float( min_clip )
            maxclip = str_to_float( max_clip )
            fig,ax = _plt.subplots( 1, 1, figsize=(nXs*scale, nYs*scale))
            rptFig = color_boxplot( subMxSums, cmapFactory, fig=fig, axes=ax, title=title,
                                   xlabels=val_filter(used_xvals), ylabels=val_filter(used_yvals),
                                   vmin=minclip, vmax=maxclip, colorbar=False, prec=prec, xlabel=xlabel, ylabel=ylabel,
                                   ticSize=ticSize, grid=grid)
            rptFig.save_to(save_to)

            if histogram:
                fig = _plt.figure()
                histdata = subMxSums.flatten()
                histdata_finite = _np.take(histdata, _np.where(_np.isfinite(histdata)))[0] #take gives back (1,N) shaped array (why?)
                histMin = min( histdata_finite ) if minclip is None else minclip
                histMax = max( histdata_finite ) if maxclip is None else maxclip
                _plt.hist(_np.clip(histdata_finite,histMin,histMax), histBins,
                          range=[histMin, histMax], facecolor='gray', align='mid')
                if save_to is not None:
                    if len(save_to) > 0:
                        _plt.savefig( _makeHistFilename(save_to) )
                    _plt.close(fig)                    
            return rptFig


        if interactive:
            interact(makeplot, 
                     min_clip=str(init_min_clip) if init_min_clip is not None else str(0),
                     max_clip=str(init_max_clip) if init_max_clip is not None else str(10) )
            rptFig = None
        else:
            rptFig = makeplot(init_min_clip, init_max_clip)

    else: #not summing up

        nIYs = nIXs = 0
        for ix in range(nXs):
            for iy in range(nYs):
                if subMxs[iy][ix] is not None:
                    nIYs,nIXs = subMxs[iy][ix].shape
                    break
        
        if invert:
            invertedSubMxs = []  #will be indexed as invertedSubMxs[inner-y][inner-x]
            for iny in range(nIYs):
                invertedSubMxs.append( [] )
                for inx in range(nIXs):
                    mx = _np.array( [[ subMxs[iy][ix][iny,inx] for ix in range(nXs) ] for iy in range(nYs)],  'd' )
                    invertedSubMxs[-1].append( mx )

            #Replace usual params with ones corresponding to "inverted" plot
            subMxs = invertedSubMxs
            used_xvals = inner_x_labels if inner_x_labels else [""]*nIXs
            used_yvals = inner_y_labels if inner_y_labels else [""]*nIYs
            xlabel = inner_x_label if inner_x_label else ""
            ylabel = inner_y_label if inner_y_label else ""
            nXs, nYs, nIXs, nIYs = nIXs, nIYs, nXs, nYs #swap nXs <=> nIXs b/c of inversion

        def makeplot(min_clip, max_clip, labels):
            minclip = str_to_float( min_clip )
            maxclip = str_to_float( max_clip )
            #print "data = ",subMxs
            fig,ax = _plt.subplots( 1, 1, figsize=(nXs*nIXs*scale*0.4, nYs*nIYs*scale*0.4))
            rptFig = nested_color_boxplot(subMxs, cmapFactory, fig=fig, axes=ax, title=title, prec=prec, 
                                        ylabels=val_filter(used_yvals), xlabels=val_filter(used_xvals), boxLabels=labels,
                                        colorbar=False, ylabel=ylabel, xlabel=xlabel, ticSize=ticSize, grid=grid)
            rptFig.save_to(save_to)

            if histogram:
                fig = _plt.figure()
                histdata = _np.concatenate( [ subMxs[iy][ix].flatten() for ix in range(nXs) for iy in range(nYs)] )
                histdata_finite = _np.take(histdata, _np.where(_np.isfinite(histdata)))[0] #take gives back (1,N) shaped array (why?)
                histMin = min( histdata_finite ) if minclip is None else minclip
                histMax = max( histdata_finite ) if maxclip is None else maxclip
                _plt.hist(_np.clip(histdata_finite,histMin,histMax), histBins,
                          range=[histMin, histMax], facecolor='gray', align='mid')
                if save_to is not None:
                    if len(save_to) > 0:
                        _plt.savefig( _makeHistFilename(save_to) )
                    _plt.close(fig)
            return rptFig


        if interactive:
            interact(makeplot,
                     min_clip=str(init_min_clip) if init_min_clip is not None else str(0),
                     max_clip=str(init_max_clip) if init_max_clip is not None else str(10),
                     labels=boxLabels)
            rptFig = None
        else:
            rptFig = makeplot(init_min_clip, init_max_clip, boxLabels)

    if rptFig:
        rptFig.set_extra_info( { 'nUsedXs': len(used_xvals),
                                 'nUsedYs': len(used_yvals) } )                     
    # rptFig.check() #DEBUG - test that figure can unpickle correctly -- if not, probably used magic matplotlib (don't do that)
    return rptFig


def generate_zoomed_boxplot(xvals, yvals, xyGateStringDict, subMxCreationFn, strs, 
                          xlabel="", ylabel="", m=None, M=None, scale=1.0, prec=0, title='sub-mx',
                          save_to=None, ticSize=14):
    """
    Creates an interactive view of one (x,y) matrix of nested box plot data.

    Given lists of x and y values, a dictionary to convert (x,y) pairs into gate strings,
    and a function to convert a "base" gate string into a matrix of floating point values,
    this function computes (x,y) => matrix data and interactively displays a single (x,y)
    matrix as a color box plot.  The user can change x and y interactively to display 
    the color box plots corresponding to different (x,y) pairs.
    
    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xyGateStringDict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.
    
    subMxCreationFn : function
        A function that takes a singe gate string parameter and returns a matrix of values to 
        display.  If the function is passed None instead of a gate string, the function 
        should return an appropriately sized matrix of NaNs to indicate these elements should
        not be displayed.

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    Returns
    -------
    None
    """

    prepStrs, effectStrs = strs
    init_min_clip = m
    init_max_clip = M
    nXs, nYs = len(xvals), len(yvals)

    from IPython.html import widgets
    from IPython.html.widgets import interact, fixed

    def val_filter(vals):  #filter to latex-ify gate strings.  Later add filter as a possible parameter
        formatted_vals = []
        for val in vals:
            if len(val) == 1 and val[0] == 0:
                formatted_vals.append(r"$\{\}$")
            elif type(val) == tuple and all([type(el) == str for el in val[1:]]) and val[0] == 0:
                formatted_vals.append( "$" + "\\cdot".join([("\\mathrm{%s}" % el) for el in val[1:]]) + "$" )
            elif type(val) == tuple and all([type(el) == str for el in val[:-1]]) and val[-1] == 0:
                formatted_vals.append( "$" + "\\cdot".join([("\\mathrm{%s}" % el) for el in val[:-1]]) + "$" )
            else:
                formatted_vals.append(val)
        return formatted_vals


    #Compute sub-matrices
    subMxs = _computeSubMxs(xvals, yvals, xyGateStringDict, subMxCreationFn)

    def str_to_float(s):
        if s is None or s == "None" or len(str(s)) == 0: return None
        else: return float(s)

    cb = False; prefix = "Chi squareds for "

    def makeplot(min_clip, max_clip, x,y):
        minclip = str_to_float(min_clip)
        maxclip = str_to_float(max_clip)
        zoomToX,zoomToY = x,y

        fig, ax = _plt.subplots( 1, 1, figsize=(len(prepStrs)*scale, len(effectStrs)*scale))
        ix,iy = xvals.index(zoomToX), yvals.index(zoomToY)
        color_boxplot( subMxs[iy][ix], cmap, norm, fig=fig, axes=ax, 
                      title=title + " for %s=%s, %s=%s" % (xlabel,str(zoomToX),ylabel,str(zoomToY)),
                      xlabels=val_filter(prepStrs), ylabels=val_filter(effectStrs), vmin=minclip, vmax=maxclip, colorbar=False, 
                      prec=prec, save_to=save_to, ticSize=ticSize)

    interact(makeplot,
             min_clip=str(init_min_clip) if init_min_clip is not None else str(0),
             max_clip=str(init_max_clip) if init_max_clip is not None else str(10),
             y=dict([(str(y),y) for y in yvals]),
             x=dict([(str(x),x) for x in xvals]) )



def chi2_boxplot( xvals, yvals, xy_gatestring_dict, dataset, gateset, strs,
                  xlabel="", ylabel="",  scale=1.0, prec='compact', title='$\\chi^2$', sumUp=False,
                  interactive=False, boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
                  save_to=None, ticSize=20, invert=False, fidPairs=None):
    """
    Create a color box plot of chi^2 values.

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    gateset : GateSet
        The gate set used to specify the probabilities and SPAM labels

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the plot.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """

    prepStrs, effectStrs = strs
    def mx_fn(gateStr):
        return chi2_matrix( gateStr, dataset, gateset, strs, minProbClipForWeighting, fidPairs)

    stdcmap = StdColormapFactory('linlog', n_boxes=10, linlg_pcntle=.05)

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, stdcmap, xlabel,ylabel,
                            scale,prec,title,sumUp,interactive,boxLabels,histogram,histBins,save_to,ticSize,
                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$")

def logl_boxplot( xvals, yvals, xy_gatestring_dict, dataset, gateset, strs,
                  xlabel="", ylabel="", scale=1.0, prec='compact', title='$\\log(\\mathcal{L})$', sumUp=False,
                  interactive=False, boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
                  save_to=None, ticSize=20, invert=False, fidPairs=None):
    """
    Create a color box plot of log-likelihood values.

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    gateset : GateSet
        The gate set used to specify the probabilities and SPAM labels

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the logl function.

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the plot.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """

    prepStrs, effectStrs = strs
    def mx_fn(gateStr):
        return logl_matrix( gateStr, dataset, gateset, strs, minProbClipForWeighting, fidPairs)

    stdcmap = StdColormapFactory('linlog', n_boxes=10, linlg_pcntle=.05)

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, stdcmap, xlabel,ylabel,
                        scale,prec,title,sumUp,interactive,boxLabels,histogram,histBins,save_to,ticSize,
                        invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$")



def blank_boxplot( xvals, yvals, xy_gatestring_dict, strs, xlabel="", ylabel="",
                  scale=1.0, title='', sumUp=False, save_to=None, ticSize=20, invert=False):
    """
    Create only the outline of a color box plot.

    This function has been useful for creating presentations
    containing box plots to introduce the viewer to these
    types of plots.

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """
    prepStrs, effectStrs = strs
    def mx_fn(gateStr):
        return _np.nan * _np.zeros( (len(strs[1]),len(strs[0])), 'd')
    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, xlabel,ylabel, 0,1,
                            scale,'compact',title,sumUp,False,False,False,0,save_to,ticSize,
                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$",True)



def zoomed_chi2_boxplot(xvals, yvals, xy_gatestring_dict, dataset, gateset, strs, 
                       xlabel="", ylabel="", m=None, M=None, scale=1.0, prec='compact', title='$\\chi^2$',
                       minProbClipForWeighting=1e-4, save_to=None, ticSize=14):
    """
    Create an interactive zoomed color box plot of chi^2 values (within an iPython notebook)

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    gateset : GateSet
        The gate set used to specify the probabilities and SPAM labels

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    Returns
    -------
    None
    """
    def mx_fn(gateStr):
        return chi2_matrix( gateStr, dataset, gateset, strs, minProbClipForWeighting)
    generate_zoomed_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, strs, xlabel, ylabel, m,M,scale,prec,title,save_to,ticSize)


def small_eigval_err_rate_boxplot( xvals, yvals, xy_gatestring_dict, dataset, directGSTgatesets,
                               xlabel="", ylabel="", m=None, M=None, scale=1.0, prec=-1, 
                               title='Error rate, extrap. from small eigenvalue of Direct GST estimate',
                               interactive=False, boxLabels=True, histogram=False, histBins=50,
                               save_to=None, ticSize=14):
    """
    Create a color box plot of per-gate error rates.

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    directGSTgatesets : dict
        Dictionary with keys == gate strings and values == GateSets linking a gate
        string to correponding direct-GST gate set.

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """

    def mx_fn(gateStr): #error rate as 1x1 matrix which we have plotting function sum up
        return _np.array( [[ small_eigval_err_rate(gateStr, dataset,  directGSTgatesets) ]] )
    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, xlabel,ylabel, m,M,
                            scale,prec,title, True,interactive,boxLabels,histogram,histBins,save_to,ticSize)


            
def gateset_with_lgst_gatestring_estimates( gateStringsToEstimate, dataset, specs,
                                        targetGateset=None, includeTargetGates=True,
                                        spamDict=None, guessGatesetForGauge=None,
                                        gateStringLabels=None, svdTruncateTo=0, verbosity=0 ):
    """
    Constructs a gateset that contains LGST estimates for gateStringsToEstimate.

    For each gate string s in gateStringsToEstimate, the constructed gateset
    contains the LGST estimate for s as separate gate, labeled either by 
    the corresponding element of gateStringLabels or by the tuple of s itself.

    Parameters
    ----------
    gateStringsToEstimate : list of GateStrings or tuples
        The gate strings to estimate using LGST

    dataset : DataSet
        The data to use for LGST
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    targetGateset : GateSet, optional
        The target gate set used by LGST to extract gate labels and an initial gauge

    includeTargetGates : bool, optional
        If True, the gate labels in targetGateset will be included in the
        returned gate set.

    spamDict : dict, optional
        Dictionary mapping (rhoVec_index,EVec_index) integer tuples to string spam labels.
        Defaults to the spam dictionary of targetGateset

    guessGatesetForGauge : GateSet, optional
        A gateset used to compute a gauge transformation that is applied to
        the LGST estimates.  This gauge transformation is computed such that
        if the estimated gates matched the gateset given, then the gate 
        matrices would match, i.e. the gauge would be the same as
        the gateset supplied. Defaults to the targetGateset.

    gateStringLabels : list of strings, optional
        A list of labels in one-to-one correspondence with the 
        gate string in gateStringsToEstimate.  These labels are
        the keys to access the gate matrices in the returned
        GateSet, i.e. gate_matrix = returned_gateset[gate_label]

    svdTruncateTo : int, optional
        The Hilbert space dimension to truncate the gate matrices to using
        a SVD to keep only the largest svdToTruncateTo singular values of
        the I_tildle LGST matrix. Defaults to no truncation.

    verbosity : int, optional
        Verbosity value to send to do_lgst(...) call.

    Returns
    -------
    Gateset
        A gateset containing LGST estimates for all the requested 
        gate strings and possibly the gates in targetGateset.
    """
    gateLabels = [] #list of gate labels for LGST to estimate

    #Add gate strings to estimate as aliases
    aliases = { }
    if gateStringLabels is not None: 
        assert(len(gateStringLabels) == len(gateStringsToEstimate))
        for gateLabel,gateStr in zip(gateStringLabels,gateStringsToEstimate):
            aliases[gateLabel] = tuple(gateStr)
            gateLabels.append(gateLabel)
    else:
        for gateStr in gateStringsToEstimate:
            newLabel = 'G'+'.'.join(tuple(gateStr))
            aliases[newLabel] = tuple(gateStr) #use gatestring tuple as label
            gateLabels.append(newLabel)
            
    #Add target gateset labels (not aliased) if requested
    if includeTargetGates and targetGateset is not None:
        for targetGateLabel in targetGateset.gates:
            if targetGateLabel not in gateLabels: #very unlikely that this is false
                gateLabels.append(targetGateLabel)
        
    return _alg.do_lgst( dataset, specs, targetGateset, gateLabels, aliases,
               spamDict, guessGatesetForGauge, svdTruncateTo, None, verbosity )

def direct_lgst_gateset( gateStringToEstimate, gateStringLabel, dataset, 
                       specs, targetGateset, svdTruncateTo=0, verbosity=0 ):
    """
    Constructs a gateset of LGST estimates for target gates and gateStringToEstimate.

    Parameters
    ----------
    gateStringToEstimate : GateString or tuple
        The single gate string to estimate using LGST

    gateStringLabel : string
        The label for the estimate of gateStringToEstimate.
        i.e. gate_matrix = returned_gateset[gate_label]

    dataset : DataSet
        The data to use for LGST
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    targetGateset : GateSet
        The target gate set used by LGST to extract gate labels and an initial gauge

    svdTruncateTo : int, optional
        The Hilbert space dimension to truncate the gate matrices to using
        a SVD to keep only the largest svdToTruncateTo singular values of
        the I_tildle LGST matrix. Defaults to no truncation.

    verbosity : int, optional
        Verbosity value to send to do_lgst(...) call.

    Returns
    -------
    Gateset
        A gateset containing LGST estimates of gateStringToEstimate
        and the gates of targetGateset.
    """
    return gateset_with_lgst_gatestring_estimates( [gateStringToEstimate], dataset, specs, targetGateset,
                                               True, None, None, [gateStringLabel], svdTruncateTo, verbosity )

def direct_lgst_gatesets(gateStrings, dataset, specs, targetGateset, svdTruncateTo=0, verbosity=0):
    """
    Constructs a dictionary with keys == gate strings and values == Direct-LGST GateSets.

    Parameters
    ----------
    gateStrings : list of GateString or tuple objects
        The gate strings to estimate using LGST.  The elements of this list
        are the keys of the returned dictionary.

    dataset : DataSet
        The data to use for all LGST estimates.
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    targetGateset : GateSet
        The target gate set used by LGST to extract gate labels and an initial gauge

    svdTruncateTo : int, optional
        The Hilbert space dimension to truncate the gate matrices to using
        a SVD to keep only the largest svdToTruncateTo singular values of
        the I_tildle LGST matrix. Defaults to no truncation.

    verbosity : int, optional
        Verbosity value to send to do_lgst(...) call.

    Returns
    -------
    dict
        A dictionary that relates each gate string of gateStrings to a
        GateSet containing the LGST estimate of that gate string stored under 
        the gate label "GsigmaLbl", along with LGST estimates of the gates in
        targetGateset.
    """    
    directLGSTgatesets = {}
    if verbosity > 0: print "--- Direct LGST precomputation ---"
    for i,sigma in enumerate(gateStrings):
        if verbosity > 0: print "--- Computing gateset for string %d of %d ---" % (i,len(gateStrings))
        directLGSTgatesets[sigma] = direct_lgst_gateset( sigma, "GsigmaLbl", dataset, specs, targetGateset,
                                                        svdTruncateTo, verbosity)
    return directLGSTgatesets



def direct_mc2gst_gateset( gateStringToEstimate, gateStringLabel, dataset, specs, targetGateset, svdTruncateTo=0,
                        minProbClipForWeighting=1e-4, probClipInterval=None, verbosity=0 ):
    """
    Constructs a gateset of LSGST estimates for target gates and gateStringToEstimate.

    Starting with a Direct-LGST estimate for gateStringToEstimate, runs LSGST
    using the same strings that LGST would have used to estimate gateStringToEstimate
    and each of the target gates.  That is, LSGST is run with strings of the form: 

    1. prepStr
    2. effectStr
    3. prepStr + effectStr
    4. prepStr + singleGate + effectStr
    5. prepStr + gateStringToEstimate + effectStr

    and the resulting Gateset estimate is returned.

    Parameters
    ----------
    gateStringToEstimate : GateString or tuple
        The single gate string to estimate using LSGST

    gateStringLabel : string
        The label for the estimate of gateStringToEstimate.
        i.e. gate_matrix = returned_gateset[gate_label]

    dataset : DataSet
        The data to use for LGST
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    targetGateset : GateSet
        The target gate set used by LGST to extract gate labels and an initial gauge

    svdTruncateTo : int, optional
        The Hilbert space dimension to truncate the gate matrices to using
        a SVD to keep only the largest svdToTruncateTo singular values of
        the I_tildle LGST matrix. Defaults to no truncation.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    probClipInterval : 2-tuple, optional
        (min,max) to clip probabilities to within GateSet probability
        computation routines (see GateSet.bulk_fill_probs)

    verbosity : int, optional
        Verbosity value to send to do_lgst(...) and do_mc2gst(...) calls.

    Returns
    -------
    Gateset
        A gateset containing LSGST estimates of gateStringToEstimate
        and the gates of targetGateset.
    """
    direct_lgst = gateset_with_lgst_gatestring_estimates( [gateStringToEstimate], dataset, specs, targetGateset,
                                                      True, None, None, [gateStringLabel], svdTruncateTo, verbosity )

    prepStrs, effectStrs = _construction.get_spam_strs(specs)

    # LEXICOGRAPHICAL VS MATRIX ORDER
    gatestrings = prepStrs + effectStrs + [ prepStr + effectStr for prepStr in prepStrs for effectStr in effectStrs ]
    for gateLabel in direct_lgst.gates:
        gatestrings.extend( [ prepStr + _objs.GateString( (gateLabel,), bCheck=False) + effectStr 
                              for prepStr in prepStrs for effectStr in effectStrs ] )

    errvec, direct_lsgst = _alg.do_mc2gst(
        dataset, direct_lgst, gatestrings, 
        minProbClipForWeighting=minProbClipForWeighting,
        probClipInterval=probClipInterval, verbosity=verbosity,
        gateLabelAliases={gateStringLabel: gateStringToEstimate} )
                                         #opt_gates=[gateStringLabel])
    return direct_lsgst
    
    
def direct_mc2gst_gatesets(gateStrings, dataset, specs, targetGateset, svdTruncateTo=0,
                        minProbClipForWeighting=1e-4, probClipInterval=None, verbosity=0):
    """
    Constructs a dictionary with keys == gate strings and values == Direct-LSGST GateSets.

    Parameters
    ----------
    gateStrings : list of GateString or tuple objects
        The gate strings to estimate using LSGST.  The elements of this list
        are the keys of the returned dictionary.

    dataset : DataSet
        The data to use for all LGST and LSGST estimates.
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    targetGateset : GateSet
        The target gate set used by LGST to extract gate labels and an initial gauge

    svdTruncateTo : int, optional
        The Hilbert space dimension to truncate the gate matrices to using
        a SVD to keep only the largest svdToTruncateTo singular values of
        the I_tildle LGST matrix. Defaults to no truncation.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    probClipInterval : 2-tuple, optional
        (min,max) to clip probabilities to within GateSet probability
        computation routines (see GateSet.bulk_fill_probs)

    verbosity : int, optional
        Verbosity value to send to do_lgst(...) and do_mc2gst(...) calls.

    Returns
    -------
    dict
        A dictionary that relates each gate string of gateStrings to a
        GateSet containing the LSGST estimate of that gate string stored under 
        the gate label "GsigmaLbl", along with LSGST estimates of the gates in
        targetGateset.
    """    
    directLSGSTgatesets = {}
    if verbosity > 0: print "--- Direct LSGST precomputation ---"
    for i,sigma in enumerate(gateStrings):
        if verbosity > 0: print "--- Computing gateset for string %d of %d ---" % (i,len(gateStrings))
        directLSGSTgatesets[sigma] = direct_mc2gst_gateset( sigma, "GsigmaLbl", dataset, specs, targetGateset,
                                                        svdTruncateTo, minProbClipForWeighting,
                                                        probClipInterval, verbosity)
    return directLSGSTgatesets


def direct_mlgst_gateset( gateStringToEstimate, gateStringLabel, dataset, specs, targetGateset, svdTruncateTo=0,
                        minProbClip=1e-6, probClipInterval=None, verbosity=0 ):
    """
    Constructs a gateset of MLEGST estimates for target gates and gateStringToEstimate.

    Starting with a Direct-LGST estimate for gateStringToEstimate, runs MLEGST
    using the same strings that LGST would have used to estimate gateStringToEstimate
    and each of the target gates.  That is, MLEGST is run with strings of the form: 

    1. prepStr
    2. effectStr
    3. prepStr + effectStr
    4. prepStr + singleGate + effectStr
    5. prepStr + gateStringToEstimate + effectStr

    and the resulting Gateset estimate is returned.

    Parameters
    ----------
    gateStringToEstimate : GateString or tuple
        The single gate string to estimate using LSGST

    gateStringLabel : string
        The label for the estimate of gateStringToEstimate.
        i.e. gate_matrix = returned_gateset[gate_label]

    dataset : DataSet
        The data to use for LGST
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    targetGateset : GateSet
        The target gate set used by LGST to extract gate labels and an initial gauge

    svdTruncateTo : int, optional
        The Hilbert space dimension to truncate the gate matrices to using
        a SVD to keep only the largest svdToTruncateTo singular values of
        the I_tildle LGST matrix. Defaults to no truncation.

    minProbClip : float, optional
        defines the minimum probability "patch point" used
        within the logl function.

    probClipInterval : 2-tuple, optional
        (min,max) to clip probabilities to within GateSet probability
        computation routines (see GateSet.bulk_fill_probs)

    verbosity : int, optional
        Verbosity value to send to do_lgst(...) and do_mlgst(...) calls.

    Returns
    -------
    Gateset
        A gateset containing MLEGST estimates of gateStringToEstimate
        and the gates of targetGateset.
    """
    direct_lgst = gateset_with_lgst_gatestring_estimates( [gateStringToEstimate], dataset, specs, targetGateset,
                                                      True, None, None, [gateStringLabel], svdTruncateTo, verbosity )

    prepStrs, effectStrs = _construction.get_spam_strs(specs)

    # LEXICOGRAPHICAL VS MATRIX ORDER
    gatestrings = prepStrs + effectStrs + [ prepStr + effectStr for prepStr in prepStrs for effectStr in effectStrs ]
    for gateLabel in direct_lgst.gates:
        gatestrings.extend( [ prepStr + _objs.GateString( (gateLabel,), bCheck=False) + effectStr 
                              for prepStr in prepStrs for effectStr in effectStrs ] )

    maxLogL, direct_mlegst = _alg.do_mlgst(
        dataset, direct_lgst, gatestrings, minProbClip=minProbClip,
        probClipInterval=probClipInterval, verbosity=verbosity,
        gateLabelAliases={gateStringLabel: gateStringToEstimate} )
    return direct_mlegst


def direct_mlgst_gatesets(gateStrings, dataset, specs, targetGateset, svdTruncateTo=0,
                        minProbClip=1e-6, probClipInterval=None, verbosity=0):
    """
    Constructs a dictionary with keys == gate strings and values == Direct-MLEGST GateSets.

    Parameters
    ----------
    gateStrings : list of GateString or tuple objects
        The gate strings to estimate using MLEGST.  The elements of this list
        are the keys of the returned dictionary.

    dataset : DataSet
        The data to use for all LGST and LSGST estimates.
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    targetGateset : GateSet
        The target gate set used by LGST to extract gate labels and an initial gauge

    svdTruncateTo : int, optional
        The Hilbert space dimension to truncate the gate matrices to using
        a SVD to keep only the largest svdToTruncateTo singular values of
        the I_tildle LGST matrix. Defaults to no truncation.

    minProbClip : float, optional
        defines the minimum probability "patch point" used
        within the logl function.

    probClipInterval : 2-tuple, optional
        (min,max) to clip probabilities to within GateSet probability
        computation routines (see GateSet.bulk_fill_probs)

    verbosity : int, optional
        Verbosity value to send to do_lgst(...) and do_mlgst(...) calls.

    Returns
    -------
    dict
        A dictionary that relates each gate string of gateStrings to a
        GateSet containing the MLEGST estimate of that gate string stored under 
        the gate label "GsigmaLbl", along with MLEGST estimates of the gates in
        targetGateset.
    """    
    directMLEGSTgatesets = {}
    if verbosity > 0: print "--- Direct MLEGST precomputation ---"
    for i,sigma in enumerate(gateStrings):
        if verbosity > 0: print "--- Computing gateset for string %d of %d ---" % (i,len(gateStrings))
        directMLEGSTgatesets[sigma] = direct_mlgst_gateset( sigma, "GsigmaLbl", dataset, specs, targetGateset,
                                                        svdTruncateTo, minProbClip, probClipInterval, verbosity)
    return directMLEGSTgatesets


def focused_mc2gst_gateset( gateStringToEstimate, gateStringLabel, dataset, specs, startGateset,
                         minProbClipForWeighting=1e-4, probClipInterval=None, verbosity=0 ):
    """
    Constructs a gateset containing a single LSGST estimate of gateStringToEstimate.

    Starting with startGateset, run LSGST with the same gate strings that LGST 
    would use to estimate gateStringToEstimate.  That is, LSGST is run with
    strings of the form:  prepStr + gateStringToEstimate + effectStr
    and return the resulting Gateset.

    Parameters
    ----------
    gateStringToEstimate : GateString or tuple
        The single gate string to estimate using LSGST

    gateStringLabel : string
        The label for the estimate of gateStringToEstimate.
        i.e. gate_matrix = returned_gateset[gate_label]

    dataset : DataSet
        The data to use for LGST
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    startGateset : GateSet
        The gate set to seed LSGST with. Often times obtained via LGST.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    probClipInterval : 2-tuple, optional
        (min,max) to clip probabilities to within GateSet probability
        computation routines (see GateSet.bulk_fill_probs)

    verbosity : int, optional
        Verbosity value to send do_mc2gst(...) call.

    Returns
    -------
    Gateset
        A gateset containing LSGST estimate of gateStringToEstimate.
    """
    prepStrs, effectStrs = _construction.get_spam_strs(specs) # LEXICOGRAPHICAL VS MATRIX ORDER
    gatestrings = [ prepStr + gateStringToEstimate + effectStr for prepStr in prepStrs for effectStr in effectStrs ]

    errvec, focused_lsgst = _alg.do_mc2gst(
        dataset, startGateset, gatestrings, 
        minProbClipForWeighting=minProbClipForWeighting,
        probClipInterval=probClipInterval, verbosity=verbosity)

    focused_lsgst.gates[gateStringLabel] = _objs.FullyParameterizedGate(
            focused_lsgst.product(gateStringToEstimate)) #add desired string as a separate labeled gate
    return focused_lsgst


def focused_mc2gst_gatesets(gateStrings, dataset, specs, startGateset,
                         minProbClipForWeighting=1e-4, probClipInterval=None, verbosity=0):
    """
    Constructs a dictionary with keys == gate strings and values == Focused-LSGST GateSets.

    Parameters
    ----------
    gateStrings : list of GateString or tuple objects
        The gate strings to estimate using LSGST.  The elements of this list
        are the keys of the returned dictionary.

    dataset : DataSet
        The data to use for all LGST and LSGST estimates.
        
    specs : 2-tuple
        A (prepSpecs,effectSpecs) tuple usually generated by calling build_spam_specs(...)

    startGateset : GateSet
        The gate set to seed LSGST with. Often times obtained via LGST.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    probClipInterval : 2-tuple, optional
        (min,max) to clip probabilities to within GateSet probability
        computation routines (see GateSet.bulk_fill_probs)

    verbosity : int, optional
        Verbosity value to send to do_mc2gst(...) call.

    Returns
    -------
    dict
        A dictionary that relates each gate string of gateStrings to a
        GateSet containing the LSGST estimate of that gate string stored under 
        the gate label "GsigmaLbl".
    """    
    focusedLSGSTgatesets = {}
    if verbosity > 0: print "--- Focused LSGST precomputation ---"
    for i,sigma in enumerate(gateStrings):
        if verbosity > 0: print "--- Computing gateset for string %d of %d ---" % (i,len(gateStrings))
        focusedLSGSTgatesets[sigma] = focused_mc2gst_gateset( sigma, "GsigmaLbl", dataset, specs, startGateset,
                                                           minProbClipForWeighting, probClipInterval, verbosity)
    return focusedLSGSTgatesets



def direct_chi2_matrix( sigma, dataset, directGateset, strs,
                       minProbClipForWeighting=1e-4, fidPairs=None):
    """
    Computes the Direct-X chi^2 matrix for a base gatestring sigma.

    Similar to chi2_matrix, except the probabilities used to compute
    chi^2 values come from using the "composite gate" of directGatesets[sigma],
    a GateSet assumed to contain some estimate of sigma stored under the
    gate label "GsigmaLbl".

    Parameters
    ----------
    sigma : GateString or tuple of gate labels
        The gate sequence that is sandwiched between each prepStr and effectStr

    dataset : DataSet
        The data used to specify frequencies and counts

    directGateset : GateSet
        GateSet which contains an estimate of sigma stored
        under the gate label "GsigmaLbl".

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight (see chi2fn).

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other elements are set to NaN.

    Returns
    -------
    numpy array of shape ( len(effectStrs), len(prepStrs) )
        Direct-X chi^2 values corresponding to gate sequences where 
        gateString is sandwiched between the each (effectStr,prepStr) pair.
    """
    chiSqMx = _np.zeros( (len(strs[1]),len(strs[0])), 'd')
    if sigma is None: return _np.nan*chiSqMx
    cntMx  = total_count_matrix(  sigma, dataset, strs, fidPairs)
    gs_direct = directGateset
    for sl in gs_direct.get_spam_labels():
        probMx = probability_matrix( _objs.GateString( ("GsigmaLbl",) ), gs_direct, sl, strs, fidPairs)
        freqMx = frequency_matrix( sigma, dataset, sl, strs, fidPairs)
        chiSqMx += _tools.chi2fn( cntMx, probMx, freqMx,
                                     minProbClipForWeighting)
    return chiSqMx

def direct_chi2_boxplot( xvals, yvals, xy_gatestring_dict, dataset, directGatesets, strs, xlabel="", ylabel="",
                        scale=1.0, prec='compact', title="Direct Chi^2", sumUp=False,
                        interactive=False, boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
                        save_to=None, ticSize=20, invert=False, fidPairs=None):
    """
    Create a color box plot of Direct-X chi^2 values.

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    directGatesets : dict
        Dictionary with keys == gate strings and values == GateSets.  
        directGatesets[sigma] must be a GateSet which contains an estimate
        of sigma stored under the gate label "GsigmaLbl".

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the plot.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """
    prepStrs, effectStrs = strs
    def mx_fn(gateStr):
        return direct_chi2_matrix( gateStr, dataset, directGatesets.get(gateStr,None), strs, minProbClipForWeighting, fidPairs)

    stdcmap = StdColormapFactory('linlog', n_boxes=10, linlg_pcntle=.05)

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, stdcmap, xlabel, ylabel,
                            scale,prec,title,sumUp,interactive,boxLabels,histogram,histBins,save_to,ticSize,
                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$",  )


def zoomed_direct_chi2_boxplot(xvals, yvals, xy_gatestring_dict, dataset, directGatesets, strs, xlabel="", ylabel="",
                                  m=None, M=None, scale=1.0, prec='compact', title="Direct Chi^2",
                                  minProbClipForWeighting=1e-4, save_to=None,ticSize=14):
    """
    Create an interactive zoomed color box plot of Direct-X chi^2 values (within an iPython notebook)

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    directGatesets : dict
        Dictionary with keys == gate strings and values == GateSets.  
        directGatesets[sigma] must be a GateSet which contains an estimate
        of sigma stored under the gate label "GsigmaLbl".

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    Returns
    -------
    None
    """
    def mx_fn(gateStr):
        return direct_chi2_matrix( gateStr, dataset, directGatesets.get(gateStr,None), strs, minProbClipForWeighting)
    generate_zoomed_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, strs, xlabel, ylabel, m,M,scale,prec,title,save_to,ticSize )


def direct_logl_matrix( sigma, dataset, directGateset, strs,
                       minProbClip=1e-6, fidPairs=None):
    """
    Computes the Direct-X log-likelihood matrix, containing the values
     of 2*( log(L)_upperbound - log(L) ) for a base gatestring sigma.

    Similar to logl_matrix, except the probabilities used to compute
    LogL values come from using the "composite gate" of directGatesets[sigma],
    a GateSet assumed to contain some estimate of sigma stored under the
    gate label "GsigmaLbl".

    Parameters
    ----------
    sigma : GateString or tuple of gate labels
        The gate sequence that is sandwiched between each prepStr and effectStr

    dataset : DataSet
        The data used to specify frequencies and counts

    directGateset : GateSet
        GateSet which contains an estimate of sigma stored
        under the gate label "GsigmaLbl".

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    minProbClip : float, optional
        defines the minimum probability clipping.

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the matrix.  Other elements are set to NaN.

    Returns
    -------
    numpy array of shape ( len(effectStrs), len(prepStrs) )
        Direct-X chi^2 values corresponding to gate sequences where 
        gateString is sandwiched between the each (effectStr,prepStr) pair.
    """
    logLMx = _np.zeros( (len(strs[1]),len(strs[0])), 'd')
    if sigma is None: return _np.nan*logLMx
    cntMx  = total_count_matrix(  sigma, dataset, strs, fidPairs)
    gs_direct = directGateset
    for sl in gs_direct.get_spam_labels():
        probMx = probability_matrix( _objs.GateString( ("GsigmaLbl",) ),
                                    gs_direct, sl, strs, fidPairs)
        freqMx = frequency_matrix( sigma, dataset, sl, strs, fidPairs)
        logLMx += _tools.two_delta_loglfn( cntMx, probMx, freqMx, minProbClip)
    return logLMx


def direct_logl_boxplot( xvals, yvals, xy_gatestring_dict, dataset, directGatesets, strs, xlabel="", ylabel="",
                        scale=1.0, prec='compact', title="Direct Log(L)", sumUp=False,
                        interactive=False, boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
                        save_to=None, ticSize=20, invert=False, fidPairs=None):
    """
    Create a color box plot of Direct-X log-likelihood values.

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    directGatesets : dict
        Dictionary with keys == gate strings and values == GateSets.  
        directGatesets[sigma] must be a GateSet which contains an estimate
        of sigma stored under the gate label "GsigmaLbl".

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the logl function.

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    fidPairs : list, optional
        A list of (iRhoStr,iEStr) tuples specifying a subset of all the prepStr,effectStr
        pairs to include in the plot.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """
    prepStrs, effectStrs = strs
    def mx_fn(gateStr):
        return direct_logl_matrix( gateStr, dataset, directGatesets.get(gateStr,None), strs, minProbClipForWeighting, fidPairs)

    stdcmap = StdColormapFactory('linlog', n_boxes=10, linlg_pcntle=.05)

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, stdcmap, xlabel, ylabel,
                            scale,prec,title,sumUp,interactive,boxLabels,histogram,histBins,save_to,ticSize,
                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$",  )


def direct2x_comp_boxplot( xvals, yvals, xy_gatestring_dict, dataset, directGatesets, strs, xlabel="", ylabel="",
                             m=None, M=None, scale=1.0, prec='compact', title="Direct 2x Chi^2 Comparison", sumUp=False,
                             interactive=False, boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
                             save_to=None, ticSize=20, invert=False):
    """
    Create a box plot indicating how well the Direct-X estimates of string s 
    predict the data for 2s (the string repeated)

    Creates a color box plot whose boxes (or box, if sumUp == True) at
    position (x,y) display the chi^2 for the (x,y) base gate string 
    **repeated twice** (if this data is available), where the probabilities
    used in the chi^2 calculation are obtained using the Direct-X gateset
    for the un-repeated (x,y) base gate string.  That is, the box(es) at
    coordinates x,y show how well the Direct-X estimates of xy_gatestring_dict[(x,y)]
    reproduce the observed frequencies of 2 * xy_gatestring_dict[(x,y)] (the
    gate string repeated twice).

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    directGatesets : dict
        Dictionary with keys == gate strings and values == GateSets.  
        directGatesets[sigma] must be a GateSet which contains an estimate
        of sigma stored under the gate label "GsigmaLbl".

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.   Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """
    prepStrs, effectStrs = strs
    def mx_fn(gateStr):
        chiSqMx = _np.zeros( (len(strs[1]),len(strs[0])), 'd')
        if gateStr is None: return _np.nan*chiSqMx
        gs_direct = directGatesets[ gateStr ] #contains "GsigmaLbl" gate <=> gateStr
        try:
        #if gateStr*2 in directGatesets: 
            cntMx  = total_count_matrix(  gateStr*2, dataset, strs)
            for sl in gs_direct.get_spam_labels():
                probMx = probability_matrix( _objs.GateString( ("GsigmaLbl","GsigmaLbl") ), gs_direct, sl, strs)
                freqMx = frequency_matrix( gateStr*2, dataset, sl, strs)
                chiSqMx += _tools.chi2fn( cntMx, probMx, freqMx, minProbClipForWeighting)
        #else:
        #    print "Warning: didn't find len-%d str: " % len(gateStr*2), (gateStr*2)[0:20]
        except:
            return _np.nan*chiSqMx #if something fails, just punt
        return chiSqMx

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, xlabel, ylabel, m,M,
                            scale,prec,title,sumUp,interactive,boxLabels,histogram,histBins,
                            save_to,ticSize,invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$" )


def direct_deviation_boxplot( xvals, yvals, xy_gatestring_dict, dataset, gateset, directGatesets,
                                 xlabel="", ylabel="", m=None, M=None, scale=1.0, prec='compact', title="Direct Deviation",
                                 interactive=False, boxLabels=True, histogram=False, histBins=50, save_to=None, ticSize=20):
    """
    Create a box plot showing the difference in max-fidelity-with-unitary
    between gateset's estimate for each base gate string and the Direct-X estimate.

    Creates a color box plot whose box at position (x,y) shows the 
    the difference between:

    1. the upper bound of the fidelity between the map corresponding to 
       this base gate string using the Direct-X estimate of this map
       (i.e. by using only data relevant to this particular string) and
       a unitary map.

    2. the upper bound of the fidelity between the map corresponding to 
       this base gate string using gateset (i.e. by multiplying together
       single gate estimates) and a unitary map.

    The plotted quantity indicates how much more "unitary", i.e. how 
    much less "depolarized", the map corresponding to each base gate
    sequence is when considering only the data immediately relevant
    to predicting that map.  If 2. is larger than 1., a zero is displayed
    so that all results are non-negative.  Large values indicate that
    the data used for fitting other gate sequences has made the estimate
    for the subject gate sequence more depolarized (~worse) than the
    data for the sequence alone would suggest.

    Parameters
    ----------
    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    directGatesets : dict
        Dictionary with keys == gate strings and values == GateSets.  
        directGatesets[sigma] must be a GateSet which contains an estimate
        of sigma stored under the gate label "GsigmaLbl".

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """
    def mx_fn(gateStr):
        if gateStr is None: return _np.nan * _np.zeros( (1,1), 'd')
        gate = gateset.product( gateStr )
        gate_direct = directGatesets[ gateStr ].gates[ "GsigmaLbl" ]
        #evals = _np.linalg.eigvals(gate)
        #evals_direct = _np.linalg.eigvals(gate_direct)
        ubF, ubGateMx = _tools.fidelity_upper_bound(gate)
        ubF_direct, ubGateMx = _tools.fidelity_upper_bound(gate_direct)
        return _np.array( [[ max(ubF_direct - ubF,0.0) ]], 'd' ) 

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, xlabel, ylabel, m,M,
                            scale,prec,title,True,interactive,boxLabels,histogram,histBins,save_to,ticSize)



def whack_a_chi2_mole_boxplot( gatestringToWhack, allGatestringsUsedInChi2Opt, 
                           xvals, yvals, xy_gatestring_dict, dataset, gateset, strs, xlabel="", ylabel="",
                           m=None, M=None, scale=1.0, prec='compact', title="Whack a Chi^2 Mole", sumUp=False,
                           interactive=False, boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
                           save_to=None, ticSize=20, whackWith=10.0, invert=False, fidPairs=None):
    """
    Create a box plot indicating how the chi^2 would change if the chi^2 of one
      base gate string blocks were forced to be smaller ("whacked").

    Creates a color box plot which displays the change in chi^2 caused by
      changing the gate set parameters such that the chi^2 of gatestringToWhack's
      (x,y) block decreases by whackWith.  This changes the gate set along
      the direction of parameter space given by the gradient of chi^2 restricted
      to only those gatestrings in gatestringToWhack's block, and the the
      displayed difference in chi^2 values are based on the linear interpolation
      of the full gradient of chi^2 after this change.

    Parameters
    ----------
    gatestringToWhack : GateString or tuple
        The **base** gate sequence for which chi^2 will be decreased.
        
    allGatestringsUsedInChi2Opt : list of GateStrings or tuples
        List of all the gate strings used to form the total chi^2 that is being decreased.

    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    gateset : GateSet
        The gate set used for computing probabilities

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    minProbClipForWeighting : float, optional
        defines the clipping interval for the statistical weight used
        within the chi^2 function (see chi2fn).

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    whackWith : float, optional
        the total amount to decrease chi^2 by.  This number just sets the
        overall scale of the numbers displayed, since the extrapolation is
        linear.

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """



    #We want the derivative of chi^2 = sum_i N_i*(p_i-f_i)^2 / p_i  (i over gatestrings & spam labels)
    # and the ability to separate the chi^2 of just "gatestringToWhack" (sandwiched with strs, optionally)
    # This latter derivative (w.r.t gateset params) gives the direction in gateset space to move to reduce 
    #   the "whacked" string(s) chi2.  Applying this direction to the full chi^2 (or to other base strings
    #   sandwiched with strs) will give the relative change in the chi^2 for these strings if the whacked 
    #   string(s) was in fact whacked.
    # D(chi^2) = sum_i N_i * [ 2(p_i-f_i)*dp_i / p_i - (p_i-f_i)^2 / p_i^2 * dp_i ]
    #          = sum_i N_i * (p_i-f_i) / p_i * [2 - (p_i-f_i)/p_i   ] * dp_i
    prepStrs, effectStrs = strs
    spamLabels = gateset.get_spam_labels() #this list fixes the ordering of the spam labels
    spam_lbl_rows = { sl:i for (i,sl) in enumerate(spamLabels) }
    vec_gs_len = gateset.num_params()

    N      = _np.empty( len(allGatestringsUsedInChi2Opt) )
    f      = _np.empty( (len(spamLabels),len(allGatestringsUsedInChi2Opt)) )
    probs  = _np.empty( (len(spamLabels),len(allGatestringsUsedInChi2Opt)) )
    dprobs = _np.empty( (len(spamLabels),len(allGatestringsUsedInChi2Opt),vec_gs_len) )

    for (i,gateStr) in enumerate(allGatestringsUsedInChi2Opt):
        N[i] = float(dataset[gateStr].total())
        for k,sl in enumerate(spamLabels):
            f[k,i] = dataset[gateStr].fraction(sl)

    evTree = gateset.bulk_evaltree(allGatestringsUsedInChi2Opt)
    gateset.bulk_fill_dprobs(dprobs, spam_lbl_rows, evTree, prMxToFill=probs)

    t = ((probs - f)/probs)[:,:,None]
    Dchi2 = N[None,:,None] * t * (2 - t) * dprobs  # (1,M,1) * (K,M,1) * (K,M,N)

    # LEXICOGRAPHICAL VS MATRIX ORDER
    if fidPairs is None:
        gatestringsToWhack = [ (prepStr + gatestringToWhack + effectStr) for prepStr in prepStrs for effectStr in effectStrs ]
    else:
        gatestringsToWhack = [ (prepStrs[i] + gatestringToWhack + effectStrs[j]) for (i,j) in fidPairs ]

    whacked_indices = [ allGatestringsUsedInChi2Opt.index(s) for s in gatestringsToWhack ]
    whacked_Dchi2 = _np.take(Dchi2,whacked_indices,axis=1) # (K,m,N) where m == len(whacked_indices)

    grad = -1.0 * _np.sum(whacked_Dchi2,axis=(0,1)) # (N) after summing over gate strings and spam labels
    dx = whackWith * grad / _np.dot(grad,grad) # direction in gateset space of direction to move to *decrease* the chi2
                                               #  of the desired base string by whackWith
    delta = _np.sum( _np.dot(Dchi2,dx), axis=0 ) # sum{(K,M), axis=1} ==> (M); the change in chi2 for each gateString
                                                 #   as a result of a unit decrease in the chi2 of the base string

    def mx_fn(gateStr):
        # LEXICOGRAPHICAL VS MATRIX ORDER
        if gateStr is None: return _np.nan * _np.zeros( (len(effectStrs),len(prepStrs)), 'd')

        if fidPairs is None:
            return _np.array( [ [ delta[ allGatestringsUsedInChi2Opt.index(prepStr + gateStr + effectStr) ] for prepStr in prepStrs ] for effectStr in effectStrs ] )
        else:
            ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
            for i,j in fidPairs:
                ret[j,i] = delta[ allGatestringsUsedInChi2Opt.index(prepStrs[i] + gateStr + effectStrs[j]) ]
            return ret

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, xlabel, ylabel, m,M,
                            scale,prec,title,sumUp,interactive,boxLabels,histogram,histBins,save_to,ticSize,
                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$" )



def whack_a_logl_mole_boxplot( gatestringToWhack, allGatestringsUsedInLogLOpt, 
                           xvals, yvals, xy_gatestring_dict, dataset, gateset, strs, xlabel="", ylabel="",
                           m=None, M=None, scale=1.0, prec='compact', title="Whack a log(L) Mole", sumUp=False,
                           interactive=False, boxLabels=True, histogram=False, histBins=50, minProbClipForWeighting=1e-4,
                           save_to=None, ticSize=20, whackWith=10.0, invert=False, fidPairs=None):
    """
    Create a box plot indicating how the log-likelihood would change if the log(L)
      of one base gate string blocks were forced to be smaller ("whacked").

    Creates a color box plot which displays the change in log(L) caused by
      changing the gate set parameters such that the log(L) of gatestringToWhack's
      (x,y) block decreases by whackWith.  This changes the gate set along
      the direction of parameter space given by the gradient of log(L) restricted
      to only those gatestrings in gatestringToWhack's block, and the the
      displayed difference in log(L) values are based on the linear interpolation
      of the full gradient of log(L) after this change.

    Parameters
    ----------
    gatestringToWhack : GateString or tuple
        The **base** gate sequence for which log(L) will be decreased.
        
    allGatestringsUsedInLogLOpt : list of GateStrings or tuples
        List of all the gate strings used to form the total log(L) that is being decreased.

    xvals, yvals : list
        List of x and y values. Elements can be any hashable quantity, and will be converted
        into x and y tic labels.  Tuples of strings are converted specially for nice latex
        rendering of gate strings.

    xy_gatestring_dict : dict
        Dictionary with keys == (x_value,y_value) tuples and values == gate strings, where
        a gate string can either be a GateString object or a tuple of gate labels.  Provides
        the mapping between x,y pairs and gate strings.  None values are allowed, and 
        indicate that there is not data for that x,y pair and nothing should be plotted.

    dataset : DataSet
        The data used to specify frequencies and counts

    gateset : GateSet
        The gate set used for computing probabilities

    strs : 2-tuple
        A (prepStrs,effectStrs) tuple usually generated by calling get_spam_strs(...)

    xlabel, ylabel : str, optional
        X and Y axis labels

    m, M : float, optional
        Min and max values of the color scale.

    scale : float, optional
        Scaling factor to adjust the size of the final figure.

    prec : int, optional
        Precision for box labels.  Allowed values are:
          'compact' = round to nearest whole number using at most 3 characters
          'compacthp' = show as much precision as possible using at most 3 characters
          int >= 0 = fixed precision given by int
          int <  0 = number of significant figures given by -int

    title : string, optional
        Plot title (latex can be used)

    sumUp : bool, optional
        False displays each matrix element as it's own color box
        True sums the elements of each (x,y) matrix and displays
        a single color box for the sum.

    interactive : bool, optional
        If true and wihin an iPython notebook, widgets are used
        to create an interactive plot whereby the user can adjust
        the min and max of the colorscale.

    boxLabels : bool, optional
        Whether box labels are displayed.  It takes much longer to 
        generate the figure when this is set to True.

    histogram : bool, optional
        Whether a histogram of the matrix element values or summed matrix
        values (depending on sumUp) should also be computed and displayed.

    histBins : int, optional
        The number of bins to use in the histogram.

    minProbClipForWeighting : float, optional
        defines the minimum probability clipping for the log(L) function.

    save_to : str, optional
        save figure to this filename (usually ending in .pdf)

    ticSize : int, optional
        size of tic marks

    whackWith : float, optional
        the total amount to decrease chi^2 by.  This number just sets the
        overall scale of the numbers displayed, since the extrapolation is
        linear.

    invert : bool, optional
        If True, invert the nesting order of the nested color box plot (applicable
        only when sumUp == False).  Use inner_x_labels and inner_y_labels to label
        the x and y axes.

    Returns
    -------
    rptFig : ReportFigure
        The encapsulated matplotlib figure that was generated.  Extra figure
        info is a dict with keys:

        nUsedXs : int
            The number of used X-values, proportional to the overall final figure width
        nUsedYs : int
            The number of used Y-values, proportional to the overall final figure height
    """

    #We want the derivative of 2*Delta_LogL = 2 * sum_i N_i*(f_i*log(f_i/p_i) + (p_i-f_i))  (i over gatestrings & spam labels)
    # and the ability to separate the 2*Delta_LogL of just "gatestringToWhack" (sandwiched with strs, optionally)
    # This latter derivative (w.r.t gateset params) gives the direction in gateset space to move to reduce 
    #   the "whacked" string(s) 2*Delta_LogL.  Applying this direction to the full 2*Delta_LogL (or to other base strings
    #   sandwiched with strs) will give the relative change in the 2*Delta_LogL for these strings if the whacked 
    #   string(s) was in fact whacked.
    # D(2*Delta_LogL) = sum_i 2* N_i * [ -f_i/p_i + 1.0 ] * dp_i

    prepStrs, effectStrs = strs
    spamLabels = gateset.get_spam_labels() #this list fixes the ordering of the spam labels
    spam_lbl_rows = { sl:i for (i,sl) in enumerate(spamLabels) }
    vec_gs_len = gateset.num_params()
      #Note: assumes *all* gateset params vary, which may not be what we always want (e.g. for TP-constrained analyses)

    N      = _np.empty( len(allGatestringsUsedInLogLOpt) )
    f      = _np.empty( (len(spamLabels),len(allGatestringsUsedInLogLOpt)) )
    probs  = _np.empty( (len(spamLabels),len(allGatestringsUsedInLogLOpt)) )
    dprobs = _np.empty( (len(spamLabels),len(allGatestringsUsedInLogLOpt),vec_gs_len) )

    for (i,gateStr) in enumerate(allGatestringsUsedInLogLOpt):
        N[i] = float(dataset[gateStr].total())
        for k,sl in enumerate(spamLabels):
            f[k,i] = dataset[gateStr].fraction(sl)

    evTree = gateset.bulk_evaltree(allGatestringsUsedInLogLOpt)
    gateset.bulk_fill_dprobs(dprobs, spam_lbl_rows, evTree, prMxToFill=probs) # spamlabel, gatestring, gsParam

    pos_probs = _np.maximum(probs, minProbClipForWeighting) #make sure all probs are positive? TODO: make this fn handle minProbClip like do_mlgst does...
    DlogL = 2 * (N[None,:] * (1.0 - f/pos_probs))[:,:,None] * dprobs # (K,M,1) * (K,M,N)

    # LEXICOGRAPHICAL VS MATRIX ORDER
    if fidPairs is None:
        gatestringsToWhack = [ (prepStr + gatestringToWhack + effectStr) for prepStr in prepStrs for effectStr in effectStrs ]
    else:
        gatestringsToWhack = [ (prepStrs[i] + gatestringToWhack + effectStrs[j]) for (i,j) in fidPairs ]

    whacked_indices = [ allGatestringsUsedInLogLOpt.index(s) for s in gatestringsToWhack ]
    whacked_DlogL = _np.take(DlogL,whacked_indices,axis=1) # (K,m,N) where m == len(whacked_indices)

    grad = -1.0 * _np.sum(whacked_DlogL,axis=(0,1)) # (N) after summing over gate strings and spam labels
    dx = whackWith * grad / _np.dot(grad,grad) # direction in gateset space of direction to move to *decrease* the 2*Delta_LogL
                                               #  of the desired base string by whackWith
    delta = _np.sum( _np.dot(DlogL,dx), axis=0 ) # sum{(K,M), axis=1} ==> (M); the change in 2*Delta_LogL for each gateString
                                                 #   as a result of a unit decrease in the 2*Delta_LogL of the base string

    def mx_fn(gateStr):
        # LEXICOGRAPHICAL VS MATRIX ORDER
        if gateStr is None: return _np.nan * _np.zeros( (len(effectStrs),len(prepStrs)), 'd')

        if fidPairs is None:
            return _np.array( [ [ delta[ allGatestringsUsedInLogLOpt.index(prepStr + gateStr + effectStr) ] for prepStr in prepStrs ] for effectStr in effectStrs ] )
        else:
            ret = _np.nan * _np.ones( (len(effectStrs),len(prepStrs)), 'd')
            for i,j in fidPairs:
                ret[j,i] = delta[ allGatestringsUsedInLogLOpt.index(prepStrs[i] + gateStr + effectStrs[j]) ]
            return ret

    return generate_boxplot( xvals, yvals, xy_gatestring_dict, mx_fn, xlabel, ylabel, m,M,
                            scale,prec,title,sumUp,interactive,boxLabels,histogram,histBins,save_to,ticSize,
                            invert, prepStrs, effectStrs, r"$\rho_i$", r"$E_i$" )



def _makeHistFilename(mainFilename):
    #Insert "_hist" before extension, e.g. /one/two.txt ==> /one/two_hist.txt
    if len(mainFilename) > 0:
        return "_hist".join(_os.path.splitext(mainFilename))    
    else: return "" #keep empty string empty, as this signals not actually saving any files
