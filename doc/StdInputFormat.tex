\documentclass{article}[11pt]

\usepackage[margin=0.5in]{geometry}
\usepackage{listings}
\usepackage{color}

%\usepackage[T1]{fontenc}
\usepackage{courier}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\small\bf\ttfamily, % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=bash,                   % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\title{GST Standard Input Formats}
\date{\today}

\begin{document}
\maketitle


\section{Introduction}
This document is intended to be a reference describing in detail the standard syntax expected of GST input files.  The level of detail in this document is more than the average customer of GST will need.

\section{Gate Strings}
The names of gates can be any string beginning with ``G'' (case-sensitive!) and followed by any number of \emph{lowercase} alphabet characters, numerals 0 through 9, or the underscore character. A gate string is a sequence of gate names.  The names don't have to be separated by anything, since a capital G marks a new gate name, but they can be separated by whitespace or an asterisk (\texttt{*}) character.  Parentheses can be used in pairs where convenient.  To repeat a gate or parenthesized string of gates the caret (\texttt{\^{}}) followed by an integer can be used.  See the examples below which demonstrate this usage. The empty gate string indicating that no gates were performed is a special case, and is denoted using the special symbol \{\}.

\section{Input file formats}

There are four types of input files.  Below we list their descriptions followed by an example of each.  A syntax common to all three types is that any line beginning with a pound sign (\#) and followed by any alphanumeric character or whitespace is considered a comment and ignored.  This is illustrated in many of the examples which follow.

\begin{itemize}
\item Gate string list files: just lists a sequence of gate strings (no counts, just strings).  Each line contains a single gate string.

\begin{lstlisting}[frame=single,caption=Example gate string list file]
G1
G1G2
G2 G3
G1*G3
GxGcoolstuff^3
G1(G1G3)^2
\end{lstlisting}

\item Gate string dictionary files:  associates (potentially long) gate strings with a (usually sort) label.  Each line contains a label name (no spaces are allowed, but underscores are), followed by a space, followed by a gate string.

%(test.dict)
\begin{lstlisting}[frame=single,caption=Example gate string dictionary file]
#My Dictionary file
1 G1
2 G1G2
3 G1G2G3G4G5G6
MyFav1 G1G1G1
MyFav2 G2^3
this1  G3*G3*G3
thatOne G1 G2 * G3
\end{lstlisting}

\item Data files:  associates gate strings with data counts.  Optionally one can include ``preamble directives'' at the beginning of the file by specifying lines that begin with ``\#\#'' before the first non-comment line of the file.  Available directives include:
\begin{itemize}
\item Lookup $=$ \emph{dictionary\_file\_name}  -- allows one to use the labels defined in the dictionary file (to make the data file more readable)
\item Columns $=$ \emph{comma\_separated\_column\_names}  -- identifies the columns that follow the gate string.  The default is ``\texttt{plus frequency, count total}'', and other available column names are \texttt{minus frequency}, \texttt{plus count}, and \texttt{minus count}.
\end{itemize}

\begin{lstlisting}[frame=single,caption=Example data file]
#My Data file
# Get string lookup data from the file test.dict, and specify that the columns
#    following the gate sequences are the plus (+) outcome frequency and the
#     total number of outcomes
## Lookup  = test.dict
## Columns = plus frequency, count total

#empty string
{}            1.0 100

#simple sequences
G1G2          0.098  100
G2 G3         0.2    100
(G1)^4        0.1   1000

#using lookups
G1 S[1]       0.9999 100
S[MyFav1]G2   0.23   100
G1S[2]^2      0.5     20
S[3][0:4]     0.2      5
G1G2G3G4      0.2      5

#different ways to concatenate gates
G_my_xG_my_y  0.5 24.0
G_my_x*G_my_y 0.5 24.0
G_my_x G_my_y 0.5 24.0
\end{lstlisting}


\item Gate set files: specifies a set of gates and state preparation and measurement operations.  Each object (gate, state prep, or measurement) is given by a block of lines containing no blank lines, and blocks are separated by blank lines.  Each block begins has the following format:
\begin{enumerate}
\item first line: a label for the object.  In the case of state preparation and measurements, this can be any name you choose but the default names of ``rho'' and ``E'' must be used for preparation an measurement respectively if you don't specify any spam label (see below).  Gate labels should be a valid gate names (so should begin with a ``G'' and followed by lowercase characters, numerals, or the underscore character as described above).
\item second line: a format name, specifying what the format of the following data.  Allowed formats are:
  \begin{itemize}
    \item StateVec : prep/measure action as a quantum state vector in the standard sigma-z basis
    \item DensityMx : prep/measure action as a density matrix in the standard sigma-z basis
    \item PauliVec : prep/measure action as a density matrix vector in the Pauli basis
    \item UnitaryMx : gate action as a unitary matrix
    \item UnitaryMxExp : gate action as a hermitian matrix that when multiplied by $-i$ and exponentiated gives the unitary gate action.
    \item PauliMx: gate action as a matrix in the Pauli basis.
  \end{itemize}
\item third line until end of block:  rows of space-delimited data elements.  A vector block contains only a single row of data, wherease matrix blocks contain multiple data rows.  Each element must evaluate to a real or complex number depending on the context (e.g. PauliMx elements must be real wheres UnitaryMx elements can be complex).  Evaluation is done via the python interpreter, so the imaginary $\sqrt{-1}$ is given by a lowercase $j$. The symbols \texttt{sqrt} and \texttt{pi} are available for use in evaluations. For example, \texttt{5}, \texttt{5+4j}, \texttt{0.1*pi}, and \texttt{ 2*(0.3+1j*pi)/sqrt(2)} are all valid element expressions (just note there can be no spaces within the element expression, as this is used to delimit the elements).
\end{enumerate}
\noindent In addition to object blocks, a gate set file may contain lines which specify spam labels.  Such lines associate a name with a (state prep, state measurement) pair, and are used to name the outcomes of different experiments. One can also specify a label to be associated with the remaining outcomes not given by other spam labels. The format of such lines is:\\
\texttt{SPAMLABEL} \emph{labelname} \texttt{=} \emph{state\_prep\_label} \emph{measurement\_label} \\
\noindent or
\texttt{SPAMLABEL} \emph{labelname} \texttt{= remainder} \\
\noindent If no spam labels are specified, the default is to create a ``plus'' label that corresponds to using the ``rho'' state preparation and the ``E'' measurement (so you must use the labels ``rho'' and ``E'' for this to work), and ``minus'' label that corresponds to all remaining outcomes.  Below are several examples of gateset files which all specify the same gate set in different ways.



%From Robin's email:  COOKBOOK:
%\begin{enumerate}
%\item You convert a dxd density matrix Rho into a $d^2$-dimensional vector as follows:
%  \begin{enumerate}
%  \item  Use the Hilbert-Schmidt inner product between matrices:  <<A|B>> = Tr( A^dagger B).
%  \item  Note that this means that the *norm* of a matrix is ||A|| = Tr( A^dagger A ).
%  \item  Pick an orthonormal basis {B_j} of matrices.  For qubits, a good choice is the Pauli operators {I,X,Y,Z}, except you have to divide them all by sqrt(2) for normalization [i.e., so that Tr( B^dagger B ) = 1]
%  \item  Now, to map Rho to a vector V, define V_j = Tr( B_j^dagger rho ).
%  \end{enumerate}
%\item You convert a dxd POVM effect E into a vector exactly as with a state Rho (see #1 above).
%
%\item To convert a CPTP map K (described in whatever way you have handy) into a 4x4 matrix G:
%  \begin{enumerate}
%  \item  Use the same orthonormal basis {B_j} that you defined above -- probably {Pauli/sqrt{2}}.
%  \item  Now, the (j,k) element of G is:  G_{j,k} = Tr( B_j^dagger K[ B_k ] ).
%  \item  How you compute K[ B_k ] depends on what representation you have for your CPTP map.  If you have it as K[ rho ] = U rho U^dagger, then you just plug that in -- so G_{j,k} = Tr( B_j^dagger U B_k U^dagger ).
%  \end{enumerate}
%\end{enumerate}

\begin{lstlisting}[frame=single,caption=First example gate set file]
# My gateset

#State prepared, specified as a density matrix
rho
DensityMx
1 0
0 0

#State measured, specified as a density matrix
E
DensityMx
0 0
0 1

#First gate, specified as a unitary matrix:  X(pi)
G1
UnitaryMx
0 1
1 0

#Second gate, specified as a unitary matrix: X(pi/2)
G2
UnitaryMx
 1/sqrt(2)   -1j/sqrt(2)
-1j/sqrt(2)   1/sqrt(2)
\end{lstlisting}

\begin{lstlisting}[frame=single,caption=Second example gate set file]
# My gateset again

#State prepared, specified as a state
rho
StateVec
1 0

#State measured as "yes" outcome, specified as a state
E
StateVec
0 1

#First gate specified as H such that the unitary gate is U = exp(-i*H):  X(pi)
G1
UnitaryMxExp
0    pi/2
pi/2    0

#Second gate, specified as H such that the unitary gate is U = exp(-i*H): X(pi/2)
G2
UnitaryMxExp
0     pi/4
pi/4     0
\end{lstlisting}

\begin{lstlisting}[frame=single,caption=Third example gate set file]
# My gateset yet again

#State prepared, specified as a vector in the Pauli basis
myrho
PauliVec
1.0/sqrt(2) 0 0 1.0/sqrt(2)

#State measured, specified as a vector in the Pauli basis
myE
PauliVec
1.0/sqrt(2) 0 0 -1.0/sqrt(2)

#First gate specified as as matrix in the Pauli basis: X(pi)
G1
PauliMx
1 0  0  0
0 1  0  0
0 0 -1  0
0 0  0 -1

#Second gate specified as matrix in the Pauli basis: X(pi/2)
G2
PauliMx
1 0 0  0
0 1 0  0
0 0 0 -1
0 0 1  0

#Must specify spam labels since I changed the state prep and 
# measure labels from the standard rho and E labels
SPAMLABEL plus = myrho myE
SPAMLABEL minus = remainder
\end{lstlisting}


\end{itemize}

Here is the Python Dataset dictionary object that results from reading the above data file (note that the dataset combines the counts of identical strings so that each key is unique):

\begin{lstlisting}[frame=single,caption=Resulting internal dictionary resulting from the example data file above]
{
()  :  {'plus': 100.0, 'minus': 0.0}
('G1', 'G2')  :  {'plus': 9.8, 'minus': 90.2}
('G2', 'G3')  :  {'plus': 20.0, 'minus': 80.0}
('G1', 'G1', 'G1', 'G1')  :  {'plus': 100.0, 'minus': 900.0}
('G1', 'G1')  :  {'plus': 99.99, 'minus': 0.01}
('G1', 'G1', 'G1', 'G2')  :  {'plus': 23.0, 'minus': 77.0}
('G1', 'G1', 'G2', 'G1', 'G2')  :  {'plus': 10.0, 'minus': 10.0}
('G1', 'G2', 'G3', 'G4')  :  {'plus': 2.0, 'minus': 8.0}
('G_my_x', 'G_my_y')  :  {'plus': 36.0, 'minus': 36.0}
}
\end{lstlisting}


\section{The Grammar}

The actual grammar, for those who care, is:
\begin{lstlisting}[frame=single,caption=The formal grammar used to parse GST input files]
 nop     :: '{}'
 gate    :: 'G' [ lowercase | digit | '_' ]+
 reflbl  :: (alpha | digit | '_')+
 strref  :: 'S' '[' reflbl ']'
 slcref  :: strref [ '[' integer ':' integer ']' ]
 expable :: gate | slcref | '(' string ')' | nop
 expdstr :: expable [ '^' integer ]*
 real    :: ['+'|'-'] integer [ '.' integer [ 'e' ['+'|'-'] integer ] ]

 string  :: expdstr [ [ '*' ] expdstr ]*
 dictline :: reflbl string
 dataline :: string [ real ]+
\end{lstlisting}

The final three grammar types correspond to the three types of input files:
\begin{itemize}
\item Gate string list files: each non-comment or blank line = string
\item Gate string dictionary files:  each non-comment or blank line = dictline
\item Data files:  each non-comment or blank line = dataline
\end{itemize}

Additionally, a data file can have a preamble before any data containing lines that specifies directives.  Each preamble line is of the form ``\#\# key = value'', and in this way one can specify a dictionary file to associate with a data file.  Each type of file can contain blank lines and comments, which are indicated by a ``\#'' at the beginning of the line.  However, there can be no blank lines before the preamble of a data file.


\end{document}



% OLD count-based example
%\begin{lstlisting}[frame=single]
%#My Data file
%# Get string lookup data from the file test.dict, and specify that the columns
%#    following the gate sequences are counts of the plus and minus outcomes
%## Lookup  = test.dict
%## Columns = plus count, minus count
%
%#empty string
%{}            100 0
%
%#simple sequences
%G1G2          9.8   90.2
%G2 G3         20    80
%(G1)^4        1e2   9e2
%
%#using lookups
%G1 S[1]       99 1
%S[MyFav1]G2   23 45
%G1S[2]^2      12 12
%S[3][0:4]     1   5
%G1G2G3G4      1   5
%
%#different ways to concatenate gates
%G_my_xG_my_y  10.00 20
%G_my_x*G_my_y 10.00 20
%G_my_x G_my_y 10.00 20
%\end{lstlisting}
%
%\end{itemize}
%
%Here is the Python Dataset dictionary object that results from reading the above data file (note that the dataset combines the counts of identical strings so that each key is unique):
%
%\begin{lstlisting}[frame=single]
%{
%()  :  {'plus': 100.0, 'minus': 0.0},
%('G1', 'G2')  :  {'plus': 9.8, 'minus': 90.2},
%('G2', 'G3')  :  {'plus': 20.0, 'minus': 80.0},
%('G1', 'G1', 'G1', 'G1')  :  {'plus': 100.0, 'minus': 900.0},
%('G1', 'G1')  :  {'plus': 99, 'minus': 1},
%('G1', 'G1', 'G1', 'G2')  :  {'plus': 23.0, 'minus': 45.0},
%('G1', 'G1', 'G2', 'G1', 'G2')  :  {'plus': 12.0, 'minus': 12.0},
%('G1', 'G2', 'G3', 'G4')  :  {'plus': 2.0, 'minus': 10.0},
%('G_my_x', 'G_my_y')  :  {'plus': 30.0, 'minus': 60.0 }
%}
%\end{lstlisting}
